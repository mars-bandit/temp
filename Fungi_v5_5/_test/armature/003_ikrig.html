<!DOCTYPE html><script type="module">
import App, { Vec3, Quat, Mat4, Transform } from "../../fungi/App.js";
import XhrQueue 			from "../../fungi/lib/XhrQueue.js";
import GltfUtil, { Gltf }	from "../../fungi/lib/GltfUtil.js";
import IKTarget				from "../../fungi.armature/IKTarget.js";

//#####################################################
App
	.init( true )
	.use_debug()
    .load_pkg( { name:"fungi.armature", bone_view:true, mat:true } )
    .set_camera( 0, 20, 3, 0, 0.7, 0 )
    .task( init )
	.then();

//#####################################################

async function init(){
    let [ json, bin ] = await XhrQueue.url( "../../files/models/", "vegeta.gltf", "vegeta.bin" );
    let e = GltfUtil.get_skin_view_entity( "Test", json, bin, "LowPolySkin" );

    let tpose = e.arm.new_pose( "tpose" );
	GltfUtil.load_pose( tpose, json, "tpose", false );
	tpose.update_world().apply();

	let rig = new IKRig()
		.use_armature( e.arm, tpose )
		.use_maximo();

	console.log( rig );

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	let pos = new Vec3( 0.3, 1.0, 0.2 );
	let b = tpose.get_bone( "LeftArm" );
	console.log( b );

	//App.Debug.pnt( b.world.pos, "green", 0.05 );
	//App.Debug.pnt( pos, "green", 0.05 );
	
	let p_wt = new Transform(),
		c_wt = new Transform();

	tpose.get_parent_world( b.idx, p_wt, c_wt );
	//App.Debug.pnt( p_wt.pos, "green", 0.05 );
	//App.Debug.pnt( c_wt.pos, "green", 0.05 );
	
	let tar = new IKTarget();
	tar.from_pos( b.world.pos, pos, Vec3.DOWN );

	tar.debug( App.Debug );

	tar.limb( rig.chains.arm_l, rig.tpose, rig.pose, p_wt );

	rig.pose.apply();

    return true;
}

class Chain{
	// #region MAIN
	bones		= new Array();	// Index to a bone in an armature / pose
	len			= 0;			// Chain Length
	len_sqr		= 0;			// Chain Length Squared, Cached for Checks without SQRT
	len_limit	= 0;			// Limit the Length of the chain.
	bone_cnt	= 0;			// How many Bones in the chain
	end_idx 	= null;			// Joint that Marks the true end of the chain
	
	// Alternate Direction and IK Stuff
	alt_fwd 	= Vec3.FORWARD.clone();
	alt_up		= Vec3.UP.clone();
	ik_solver 	= null;
	// #endregion ////////////////////////////////////////////////

	// #region GETTERS / SETTERS
	add_bone( idx, len ){
		let o = { idx, len };

		this.bones.push( o );
		this.cnt++;
		this.len		+= len;
		this.len_sqr	= this.len * this.len;
		return this;
	}

	// Get Skeleton Index of Bones
	first(){ return this.bones[0].idx; }
	last(){ return this.bones[ this.cnt-1 ].idx; }
	idx( i ){ return this.bones[ i ].idx; }

	set_alt( fwd, up, tpose=null ){
		if( tpose ){
			let b = tpose.bones[ this.bones[ 0 ].idx ],
				q = Quat.invert( b.world.rot );	// Invert World Space Rotation 

			this.alt_fwd.from_quat( q, fwd );	// Use invert to get direction that will Recreate the real direction
			this.alt_up.from_quat( q, up );	
		}else{
			this.alt_fwd.copy( fwd );
			this.alt_up.copy( up );
		}
		return this;
	}
	// #endregion ////////////////////////////////////////////////
}

class IKRig{
	arm 	= null;		// Reference back to Armature Component
	tpose	= null;		// TPose or Bind Pose, TPose is better for IK
	pose	= null;		// Pose object to manipulate before applying to bone entities
	chains	= {};		// Bone Chains, Usually Limbs / Spine / Hair / Tail
	points	= {};		// Main Single Bones of the Rig, like Head / Hip / Chest

	use_armature( arm, tpose=null ){
		this.arm	= arm;
		this.pose	= arm.new_pose( "ikrig_pose" );
		this.tpose	= ( tpose )? tpose : arm.new_pose();

		//-----------------------------------------
		// If TPose was self created, it does not have its world space Computed.
		if( !tpose ) this.tpose.update_world();

		return this;
	}

	use_maximo(){
		this
		.add_point( "hip", "Hips" )
		.add_point( "head", "Head" )
		.add_point( "neck", "Neck" )
		.add_point( "chest", "Spine2" )
		.add_point( "foot_l", "LeftFoot" )
		.add_point( "foot_r", "RightFoot" )
		.add_chain( "arm_r", [ "RightArm", "RightForeArm" ],  "RightHand" )
		.add_chain( "arm_l", [ "LeftArm", "LeftForeArm" ], "LeftHand" )
		.add_chain( "leg_r", [ "RightUpLeg", "RightLeg" ], "RightFoot" )
		.add_chain( "leg_l", [ "LeftUpLeg", "LeftLeg" ], "LeftFoot" ) 
		.add_chain( "spine", [ "Spine", "Spine1", "Spine2" ] );

		// Set Direction of Joints on th Limbs
		this.chains.leg_l.set_alt( Vec3.DOWN, Vec3.FORWARD, this.tpose );
		this.chains.leg_r.set_alt( Vec3.DOWN, Vec3.FORWARD, this.tpose );
		this.chains.arm_r.set_alt( Vec3.RIGHT, Vec3.BACK, this.tpose );
		this.chains.arm_l.set_alt( Vec3.LEFT, Vec3.BACK, this.tpose );
		return this;
	}

	// #region MANAGE POINTS AND CHAINS
	add_point( name, b_name ){
		this.points[ name ] = { 
			idx : this.arm.names[ b_name ]
		}; 
		return this;
	}
	
	add_chain( name, name_ary, end_name=null, ik_solver=null ){
		let i, b, ch = new Chain(); // axis
		for( i of name_ary ){
			b = this.pose.get_bone( i );
			ch.add_bone( b.idx, b.len );
		}

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		if( end_name ){
			ch.end_idx = this.pose.get_bone( end_name ).idx;
		}

		ch.ik_solver = ik_solver;

		this.chains[ name ] = ch;
		return this;
	}
	// #endregion /////////////////////////////////////////////////////////
}


//#####################################################
</script>
<html><head><style>html,body{ margin:0px; padding:0px; width:100%; height:100%; }</style>
</head><body><canvas id="pg_canvas"></canvas></body></html>