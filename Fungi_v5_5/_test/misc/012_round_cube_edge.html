<!DOCTYPE html><script type="module">
import App, { Maths, Vec3, Quat, Mat4, Transform, Colour } from "../../fungi/App.js";
import XhrQueue     from "../../fungi/lib/XhrQueue.js";
import Wireframe    from "../../fungi/shaders/Wireframe.js";

//#####################################################
App
	.init( true )
    .load_shaders( "LowPoly.js" )
    //.load_shaders( "Texture.js" )
    
	.use_debug()
	.set_camera( 0, 20, 5, 0, 0.5, 0 )
	.task( init )
	.then();

//#####################################################

async function init(){
    let img     = await XhrQueue.add( "../../files/textures/uv_test_01.jpg" ).then();
    let tex0    = App.texture.new( "uv_test_01", img );

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    //sphere_corner();
    /*
    let ary   = edge_grid();
    let verts = vertary_to_buf( ary.verts );
    //let verts = vertary_rot_buf( ary.verts );
    let idx   = grid_tri_idx( 9, 9 );

    let mesh    = App.mesh.from_data( "x", verts, 3, idx, null, new Float32Array( ary.uv ) );
    let mat     = App.shader.new_material( "Texture", { base_tex:tex0 } );
    let e       = App.mesh_entity( "x", mesh, mat );
    */

    let panel = edge_grid();
    panel.indices = grid_tri_idx( 9, 9 );

    let buf  = {
        verts   : new Array(),
        indices : new Array(),
        uv      : new Array(),
    };

    buf_rot_append( buf, panel, (v,o)=>o.copy( v ) );
    buf_rot_append( buf, panel, VRot90.xp );
    buf_rot_append( buf, panel, VRot90.xp_yp );
    buf_rot_append( buf, panel, VRot90.xp_yp_yp );
    buf_rot_append( buf, panel, VRot90.xp_yn );
    buf_rot_append( buf, panel, VRot90.xp_xp );

    // 

    //let verts = vertary_to_buf( ary.verts );
    //let verts = vertary_rot_buf( ary.verts );
    //let idx     = grid_tri_idx( 9, 9 );

    let mesh    = App.mesh.from_data( "x", new Float32Array( buf.verts ), 3, new Uint16Array(buf.indices), null, new Float32Array( buf.uv ) );
    //let mat     = App.shader.new_material( "Texture", { base_tex:tex0 } ).set_cullface( false );
    let mat     = App.shader.new_material( "LowPoly" ).set_cullface( false );
    let e       = App.mesh_entity( "x", mesh, mat );
    e.node.set_pos( 0, 1.0, 0 );

    Wireframe.append_tri( e.draw, buf.indices, buf.verts, { line_color:"#ffffffB0", face_color:"#00000000" } );
    
    //let rot_x_f = ( v, o ) => o.set( v.z, v.x, v.y );       // zxy
    //let rot_x_b = ( v, o ) => o.set( v.x, v.z, -v.y );      // xzy
    //let rot_z_r = ( v, o ) => o.set( v.y, v.z, v.x );       // yzx
    //let rot_z_l = ( v, o ) => o.set( -v.y, v.z, v.x );
    //let rot = ( v, o ) => o.set( v.y, -v.x, v.z );

    //let o   = new Vec3();
    //let oo  = new Vec3();
    //for( let v of verts ){
        //App.Debug.pnt( rot_x_f( v, o ), "orange" );
    //    App.Debug.pnt( rot( v, o ), "white" );
    //}

    
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	return true;
}

function sphere_corner(){
    let s_lat, c_lat, s_lon, c_lon, x, y, z, i, j;
    let res     = 4;
    let lon     = 0;
    let lat     = 0; 
    let radius  = 0.5;
    let out     = new Array( res ).fill( null ).map( _=>new Array( res+1 ).fill( null ) );
    
    // Move Vertical
    for( i=0; i < res; i++ ){
        lon     = Maths.PI_H - Maths.PI_H * ( i / res );
        s_lon   = Math.sin( lon );
        c_lon   = Math.cos( lon );

        // Draw Horizontal Arc
        for( j=0; j <= res; j ++ ){
            lat     =  Maths.PI_270 - Maths.PI_H * ( j / res );
            s_lat   = Math.sin( lat );
            c_lat   = Math.cos( lat );

            x       = radius * s_lon * c_lat;
            z       = radius * s_lon * s_lat;
            y       = radius * c_lon;

            out[ i ][ j ] = new Vec3( x, y, z );
            App.Debug.pnt( [x, y, z ] );
        }
    }

    
    // Top Point
    //App.Debug.pnt( [0,radius,0] );
    console.log( out );
}

function buf_rot_append( buf, obj, fn_rot ){
    let offset  = buf.verts.length / 3;
    let len     = obj.verts.length;
    let v, o    = new Vec3();

    for( v of obj.verts ){
        fn_rot( v, o );
        buf.verts.push( o[ 0 ], o[ 1 ], o[ 2 ] );
    }

    for( v of obj.uv )      buf.uv.push( v );
    for( v of obj.indices ) buf.indices.push( offset + v );
}


function edge_grid( sx=2, sy=2, sz=2, r=0.5, div=4 ){
    let mx  = sx / 2, 
        my  = sy / 2,
        mz  = sz / 2,
        len = div * 2;

    let verts   = new Array();
    let uv      = new Array();
    let norm    = new Array();

    let bit, j, i, t, s, x, y, z, v;
    
    y = my;

    // Use corners kinda like Marching Squares
    let corners = [
        new Vec3( r-mx, my-r, r-mz ),
        new Vec3( mx-r, my-r, r-mz ),
        new Vec3( r-mx, my-r, mz-r ),
        new Vec3( mx-r, my-r, mz-r ),
    ];
    
    //App.Debug.pnt( corners[0], "green" );
    //App.Debug.pnt( corners[1], "green" );
    //App.Debug.pnt( corners[2], "green" );
    //App.Debug.pnt( corners[3], "green" );

    let row = ( z, zbit ) => {
        let t, bit;
        let uv_z = Maths.norm(-mz, mz, z );

        for( i=0; i <= len; i++ ){
            bit = ( i <= div )? 0 : 1;
            t   = Maths.triangle_wave( i / div ); // 0 > 1 > 0
            s   = ( i <= div )? -1 : 1;           // Sign
            x   = ( mx * s ) + ( r * t * -s );    // Flip Signs based if i <= div

            
            v   = new Vec3( x, y, z ).sub( corners[ bit | zbit ] ).norm();  // Normalize the Vertex from the corner origin point
            norm.push( v[0], v[1], v[2] );                                  // Save it
            v.scale( r ).add( corners[ bit | zbit ] );                      // Scale to Corner Radius and move back into position

            verts.push( v );                                                // Save Vert
            uv.push( Maths.norm( -mx, mx, x ), uv_z );
            //App.Debug.pnt( v );

            // Start the mirror side when done with the first side
            if( t == 1 ){
                v = new Vec3( mx-r, y, z ).sub( corners[ 1 | zbit ] ).norm();
                norm.push( v[0], v[1], v[2] );
                v.scale( r ).add( corners[ 1 | zbit ] );
                
                verts.push( v );
                uv.push( Maths.norm( -mx, mx, mx-r ), uv_z );
                // App.Debug.pnt( v );
            }
        }
    };

    for( j=0; j <= len; j++ ){
        // Compute Z Position
        bit = ( j <= div )? 0 : 2;
        t   = Maths.triangle_wave( j / div ); // 0 > 1 > 0
        s   = ( j <= div )? -1 : 1;           // Sign
        z   = ( mz * s ) + ( r * t * -s );    // Flip Signs based if i <= div

        row( z, bit );                        // Draw Row
        if( t == 1 ) row( mz-r, 2 );          // Start Mirror Side
    }

    return { verts, uv, norm };
}

function vertary_to_buf( ary ){
    let size = ary.length * 3;
    let out  = new Float32Array( size );
    let v, i = 0;

    for( v of ary ){
        out[ i++ ] = v[ 0 ];
        out[ i++ ] = v[ 1 ];
        out[ i++ ] = v[ 2 ];
    }
    return out;
}

function vertary_rot_buf( ary ){
    let size = ary.length * 3;
    let out  = new Float32Array( size );
    let v, i = 0;

    let o = new Vec3();

    for( v of ary ){
        // xz-y Rot X - 90
        // x-zy Rot X + 90
        // y-xz Rot Z + 90
        // -yxz Rot Z - 90
        // -zyx Rot Y + 90
        // zy-x Rot Y - 90

        // -y-zx    = Rot X+90 Then Rot Y-90
        // y-z-x    = Rot X+90 Then Rot Y+90
        // -x-z-y   = Rot X+90 Then Rot Y+90 Then Rot Y+90
        // x-y-z    = Rot X+90 Then Rot X+90

        //out[ i++ ] = v[ 0 ];
        //out[ i++ ] = -v[ 2 ];
        //out[ i++ ] = v[ 1 ];

        VRot90.xp_xp( v, o );
        
        out[ i++ ] = o[ 0 ];
        out[ i++ ] = o[ 1 ];
        out[ i++ ] = o[ 2 ];

    }
    return out;
}

class VRot90{
    // #region SINGLE AXIS ROTATION
    static xp( v, o ){ let x = v[0], y = v[1], z = v[2]; o[0] = x; o[1] = -z; o[2] = y; return o; }    // x-zy rot x+90
    static xn( v, o ){ let x = v[0], y = v[1], z = v[2]; o[0] = x; o[1] = z; o[2] = -y; return o; }    // xz-y rot x-90
    
    static yp( v, o ){ let x = v[0], y = v[1], z = v[2]; o[0] = -z; o[1] = y; o[2] = x; return o; }    // -zyx rot y+90
    static yn( v, o ){ let x = v[0], y = v[1], z = v[2]; o[0] = z; o[1] = y; o[2] = -x; return o; }    // zy-x rot y-90

    static zp( v, o ){ let x = v[0], y = v[1], z = v[2]; o[0] = y; o[1] = -x; o[2] = z; return o; }    // y-xz rot z+90
    static zn( v, o ){ let x = v[0], y = v[1], z = v[2]; o[0] = -y; o[1] = x; o[2] = z; return o; }    // -yxz rot z-90
    // #endregion

    // #region COMBINATIONS
    static xp_yn( v, o ){ let x = v[0], y = v[1], z = v[2]; o[0] = -y; o[1] = -z; o[2] = x; return o; }     // -y-zx rot x+90, y-90
    static xp_yp( v, o ){ let x = v[0], y = v[1], z = v[2]; o[0] = y; o[1] = -z; o[2] = -x; return o; }     // y-z-x rot x+90, y+90
    static xp_yp_yp( v, o ){ let x = v[0], y = v[1], z = v[2]; o[0] = -x; o[1] = -z; o[2] = -y; return o; } // -x-z-y rot x+90, y+90, y+90
    static xp_xp( v, o ){ let x = v[0], y = v[1], z = v[2]; o[0] = x; o[1] = -y; o[2] = -z; return o; }     // x-y-z rot x+90, x+90
    // #endregion
}

function grid_tri_idx( x_cells, y_cells ){
    let ary     = new Array(),
        col_cnt = x_cells + 1,
        x, y, a, b, c, d;

    for( y=0; y < y_cells; y++ ){
        for( x=0; x < x_cells; x++ ){
            a   = y * col_cnt + x;
            b   = a + col_cnt;
            c   = b + 1
            d   = a + 1;
            ary.push( a, b, c, c, d, a );
        }
    }

    return ary;
}


//#####################################################
</script>
<html><head><style>html,body{ margin:0px; padding:0px; width:100%; height:100%; }</style>
</head><body><canvas id="pg_canvas"></canvas></body></html>