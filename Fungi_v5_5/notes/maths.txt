~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Alpha Blending

Classic  out = Src.RGB * S.A + Dest * ( 1 - Src.A );

Actual 
out.a = Src.A + Dest.A * ( 1 - Src.A );
if( out.a == 0 ) out.rgb = 0;
else
	out.rgb = ( Src.RGB * Src.A + Dest.RGB * Dest.A * ( 1 - Src.A ) ) / out.a;



~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
determinant, find what direction a point is in relation to a line, left/right 
https://stackoverflow.com/questions/1560492/how-to-tell-whether-a-point-is-to-the-right-or-left-side-of-a-line

Use the sign of the determinant of vectors (AB,AM), where M(X,Y) is the query point:
position = sign((Bx - Ax) * (Y - Ay) - (By - Ay) * (X - Ax))
It is 0 on the line, and +1 on one side, -1 on the other side.

public bool isLeft(Point a, Point b, Point c){
     return ((b.X - a.X)*(c.Y - a.Y) - (b.Y - a.Y)*(c.X - a.X)) > 0;
}
Where a = line point 1; b = line point 2; c = point to check against.
If the formula is equal to 0, the points are colinear.
If the line is horizontal, then this returns true if the point is above the line.


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is perpendicular to the line,
x = y1-y2;
y = x2-x1;


https://twitter.com/Gelada/status/1305890934681460737
Four different views of the function f(x,y) = x^3-2xy^2+y^3.


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
https://discourse.threejs.org/t/camera-zoom-to-fit-object/936/24
function fitCameraToSelection( camera, controls, selection, fitOffset = 1.2 ) {
  
  const box = new THREE.Box3();
  
  for( const object of selection ) box.expandByObject( object );
  
  const size = box.getSize( new THREE.Vector3() );
  const center = box.getCenter( new THREE.Vector3() );
  
  const maxSize = Math.max( size.x, size.y, size.z );
  const fitHeightDistance = maxSize / ( 2 * Math.atan( Math.PI * camera.fov / 360 ) );
  // const fitHeightDistance = maxSize / ( 2 * Math.atan( (camera.fov * Math.PI / 180) / 2 ) ); // also works
  const fitWidthDistance = fitHeightDistance / camera.aspect;
  const distance = fitOffset * Math.max( fitHeightDistance, fitWidthDistance );
  
  const direction = controls.target.clone()
    .sub( camera.position )
    .normalize()
    .multiplyScalar( distance );

  controls.maxDistance = distance * 10;
  controls.target.copy( center );
  
  camera.near = distance / 100;
  camera.far = distance * 100;
  camera.updateProjectionMatrix();

  camera.position.copy( controls.target ).sub(direction);
  
  controls.update();
  
}