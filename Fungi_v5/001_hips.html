<!DOCTYPE html><script type="module">
import App							from "./fungi/App.js";
import Maths,{Vec3,Quat,Transform}	from "../../fungi/maths/Maths.js";

import XhrQueue 					from "../../fungi/lib/XhrQueue.js";
import GltfUtil, {Gltf}				from "../../fungi/lib/GltfUtil.js";
import Animation					from "../../fungi/lib/Animation.js";

import PoseAnimator					from "../../fungi.armature/PoseAnimator.js";
import IKTarget 					from "../../fungi.armature/IKTarget.js";
import IKRig						from "../../fungi.armature/IKRig.js";

//#####################################################
App.builder( true )
	.use_armature()
	.load_shaders( "../fungi.armature/LowPolySkin.js" )
	.set_camera( 0, 10, 4, 0, 0.75, 0 )
	.add( init )
	//.render_loop( on_draw )
	.render_on_mouse()
	.build();

/* NOTES
1.
	First we need an object manage groups of bones ( Chains ). IK
	Tends to be applied to bones that are connected in a Parent-Child relationship
	in groups called Chains. We can look at an arm as a chain of 2 Bones.
	( Look Over the IK Rig Component )

2. Rig consists of Chains and Single Bone Points. Points are like Hands, Feet, Head, etc.
3. IK Target. Normally  the target for IK tends to be a point called the End Effector. 
	Maybe go threw this with limbs
*/

// #region INITIALIZE

let gSrc, gModelA, gModelB, gAnimate, gIKPose;
function on_draw( dt, ss ){ gAnimate( dt * 0.2 ); }

async function init(){
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Download Resources
	let dl = await XhrQueue.url( "../../files/" )
		.grp( "src", "anim/Walking.gltf", "json", "anim/Walking.bin", "bin" )
		.grp( "ma", "models/vegeta.gltf", "json", "models/vegeta.bin", "bin" )
		//.grp( "mb", "models/robo_trex.gltf", "json", "models/robo_trex.bin", "bin" )
		.then();

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Load Resources
	if( dl.src ) gAnimate = load_src( dl.src.json, dl.src.bin );
	if( dl.ma ) load_mesh_a( dl.ma.json, dl.ma.bin );
	if( dl.mb ) load_mesh_b( dl.mb.json, dl.mb.bin );

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Misc
	gIKPose = new IKPose();

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	gAnimate( 0.5 );
	//IKCompute.run( gSrc, gIKPose );
	return true;
}

function load_src( json, bin ){
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Load Animation Armature, setup IK Rig For it.
	// NOTE: Normally Need a TPose, but the Animation has a T Pose By Default.
	let e		= GltfUtil.get_bone_view( "src", json, bin );
	let rig 	= e.add_com( "IKRig" )
		.init( null, true, IKRig.ARM_MIXAMO )
		.recompute_from_tpose(); // Mesh requires a few bits to be recomputed because of Mixamo Scaling

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Load First Animation in GLTF, and Setup Animator
	let anim	= new Animation( Gltf.get_animation( json, bin ), true );
	let pm		= new PoseAnimator();

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Return a Closure that will run the IK Retarget Animation
	gSrc  = e;
	return ( dt )=>{
		//-----------------------------
		// ANIMATE SOURCE POSE
		pm.tick( dt ).update( anim, rig.pose );	// Update Pose with next frame
		rig.apply_pose();						// Apply Pose to Armature Bones

		//-----------------------------
		IKCompute.run( gSrc, gIKPose );
		IKVisualize.run( gSrc, gIKPose );
		
		//if( gModelA ){
		//	gIKPose.apply_rig( gModelA.IKRig );
		//	gModelA.IKRig.apply_pose();
		//}

		//if( gModelB ){
		//	gIKPose.apply_rig( gModelB.IKRig );
		//	gModelB.IKRig.apply_pose();
		//}
	}
}

function load_mesh_a( json, bin ){
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Create Rendering Entity
	let mat		= App.new_mat( "LowPolySkin", {color:"#ffffff"} );
	let e		= GltfUtil.get_debug_view( "target_a", json, bin, mat );
	//let e		= GltfUtil.get_bone_view( "target_a", json, bin );

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// For IK, We need a TPose. Use custom data stored in 
	// GLTF to load up the TPose for the Model
	let tpose	= GltfUtil.get_pose( e, json, "tpose", true );
	let rig 	= e.add_com( "IKRig" ).init( tpose, false );
	tpose.apply();

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Misc Settings
	rig.points.head.idx = rig.points.neck.idx;	// Lil hack cause Head Isn't Skinned Well.
	e.Node.set_pos( 1, 0, 0 );					// Move it to the Left, So it doesn't block src.
	gModelA = e;								// Save for Global Access
}

function load_mesh_b( json, bin ){	
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Create Rendering Entity
	let mat		= App.new_mat( "LowPolySkin", {color:"#ffffff"} );
	let e		= GltfUtil.get_debug_view( "target_b", json, bin, mat );
	// let e		= GltfUtil.get_bone_view( "target_b", json, bin );

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Robo Rex has a unique skeleton, so there is no default Rig function for it
	// So that means we need to defined the Points and Chains of the Rig.
	let tpose	= GltfUtil.get_pose( e, json, "tpose", true );
	let rig 	= e
		.add_com( "IKRig" )
		.init( tpose, false, 0 )

		.add_point( "hip", "hip" )
		.add_point( "head", "face_joint" )
		.add_point( "foot_l", "LeftFoot" )
		.add_point( "foot_r", "RightFoot" )

		.add_point( "wing_l", "left_wing" )
		.add_point( "wing_r", "right_wing" )

		.add_chain( "leg_r", [ "RightUpLeg", "RightKnee", "RightShin" ], "RightFoot", "three_bone" ) //"z", 
		.add_chain( "leg_l", [ "LeftUpLeg", "LeftKnee", "LeftShin" ], "LeftFoot", "three_bone" ) // "z", 
		.add_chain( "spine", [ "Spine", "Spine1" ] )
		.add_chain( "tail", ["tail_1","tail_2","tail_3","tail_4","tail_5","tail_6","tail_7"] )
		.set_leg_lmt( null, -0.1 )
	;

	// Using Quaternion Inverse Direction to set UP and FORWARD Direction
	// Since leg bones point downward, we define Down as the IK FORWARD Direction.
	// Then we use forward for IK UP, since thats the direction the Knees point.
	// This follows the idea of Swing & Twist, IK FORWARD is our Swing Vector, IK UP is our Twist Vector
	rig.chains.leg_l.set_alt( Vec3.DOWN, Vec3.FORWARD, rig.tpose ); // ( fwd, up, tpose )
	rig.chains.leg_r.set_alt( Vec3.DOWN, Vec3.FORWARD, rig.tpose );
	tpose.apply();

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Misc Settings
	e.Node.set_pos( -1.0, 0, 0 ); // Move it to the Left, So it doesn't block src.
	gModelB = e;
}

// #endregion ///////////////////////////////////////////

// #region IK CLASSES

// Hold the IK Information, then apply it to a Rig
class IKPose{
	hip = {
		bind_height	: 0, // Use to help Scale movement.
		movement 	: new Vec3(),
		dir			: new Vec3(),
		twist		: 0,
	};

	apply_rig( rig ){
		this.hip( rig );
	}

	hip( rig ){
		let b_info	= rig.points.hip,							// Bone Info
				tb 		= rig.tpose.bones[ b_info.idx ],			// TPose Bone (Bind Pose info)
				pb		= rig.pose.bones[ b_info.idx ],				// Pose Bone
				q 		= new Quat(),
				p 		= new Vec3();
			/*
			//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			// ROTATION
			q	.from_unit_vecs( Vec3.FORWARD, this.hip.dir )		// Compute Swing Rotation, TODO, Need Bone's actual Forward Direction if different
				.mul( tb.world.rot )								// Add World Space Bind Pose of the bone
				.pmul_axis_angle( this.hip.dir, this.hip.twist );	// Add Twist, using direction as rotation axis

			if( tb.p_idx != null ){									// To Local Space
				q.pmul_invert( rig.tpose.bones[ tb.p_idx ].world.rot );
			}
			*/
			this.apply_look_twist( rig, rig.points.hip.idx, this.hip, true );

			//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			// TRANSLATION
			let h_scl = this.hip.bind_height / tb.world.pos.y;		// Create Scale value from Src's Hip Height and Target's Hip Height
			
			p	.from_scale( this.hip.pos_dif, h_scl )				// Scale the Translation of Source Animation
				.add( tb.world.pos );								// Apply translation to Hip's Bind Position

			p[0] = tb.world.pos[0];
			p[2] = tb.world.pos[2];

			rig.pose.set_bone( b_info.idx, null, p );					// Save Rotation/Translation back to the pose.
	}

	// #region Helper Functions
	look_twist( rig, b_idx, ik, do_twist=false ){
		let tb	= rig.tpose.bones[ b_idx ],
			pb	= rig.pose.bones[ b_idx ],
			q	= new Quat(),
			v	= new Vec3(),
			pt	= new Transform(),
			ct	= new Transform();

		rig.pose.get_parent_world( b_idx, pt );	// Get Parent Bone's World Space Transform
		ct.from_add( pt, tb.local );			// Add Bone's Bind Local Space

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// Inverting the BIND World Space rotation, can then transform
		// a vector that can be recreated in the right orientation from
		// the animated bone. In this case, I want to use WS Forward as my Main Vector
		// For most of the bones I'll use with this function, WS FWD does the job.
		q.from_invert( tb.world.rot );
		let fwd_alt = Vec3.transform_quat( Vec3.FORWARD, q ); 

		v.from_quat( ct.rot, fwd_alt );	// Re create FWD direction based on current animated pose

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		q.from_unit_vecs( v, ik.dir )			// Compute Swing Rotation
		q.mul( ct.rot );						// Add World Space Rotation
		//if( do_twist ) q.pmul_axis_angle( ik.dir, ik.twist );	// Add Twist, using direction as rotation axis\
		q.pmul_axis_angle( ik.dir, ik.twist );	// Add Twist, using direction as rotation axis
		q.pmul_invert( pt.rot );				// To Local Space

		rig.pose.set_bone( b_idx, q );		
	}
	// #endregion
}



// Read the current pose of a Rig then compute data to be saved to IK Pose.
class IKCompute{
	static run( e, ik_pose ){
		let rig = e.IKRig;
		rig.pose.update_world();
		App.Debug.reset();

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		this.hip( rig, ik_pose );
	}

	static hip( rig, ik_pose ){
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// First thing we need is the Hip bone for the Animated Pose
		// Plus what the hip's Bind Pose values as well.
		// We use these two states to determine what changed from the TPose.
		let b_info	= rig.points.hip,					// Rig Hip Info
			pose 	= rig.pose.bones[ b_info.idx ],		// Animated Pose Bone
			bind 	= rig.tpose.bones[ b_info.idx ];	// TPose Bone

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// Lets create the Quaternion Inverse Direction base On the
		// TBone's World Space rotation. We don't really know the orientation 
		// of the bone's starting rotation and our targets might have their own
		// orientation, so by doing this we can easily say no whatever what the
		// default direction of the bone, we want to say all hips bones FORWARD and the 
		// tail of the bone points UP.
		let q_inv 		= Quat.invert( bind.world.rot ),				// This part can be optimized out and Saved into the Rig Hip's Data.
			alt_fwd		= Vec3.transform_quat( Vec3.FORWARD, q_inv ),
			alt_up		= Vec3.transform_quat( Vec3.UP, q_inv );

		let pose_fwd 	= Vec3.transform_quat( alt_fwd, pose.world.rot ),
			pose_up 	= Vec3.transform_quat( alt_up, pose.world.rot );

		/* VISUAL DEBUG TPOSE AND ANIMATED POSE DIRECTIONS 
		let pos = pose.world.pos.clone().add( [0,0,0.1] );
		App.Debug.ln( pos, Vec3.add(pos, Vec3.FORWARD), "white" );
		App.Debug.ln( pos, Vec3.add(pos, Vec3.UP), "white" );
		App.Debug.ln( pos, Vec3.scale( pose_fwd, 0.8 ).add( pos ), "orange" );
		App.Debug.ln( pos, Vec3.scale( pose_up, 0.8 ).add( pos ), "orange" );
		*/

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// With our directions known between our TPose and Animated Pose, Next we
		// start to calculate the Swing and Twist Values to transfrom one Rotation to Another.

		let swing = Quat.unit_vecs( Vec3.FORWARD, pose_fwd )	// First we create a swing rotation from one dir to the other.
			.mul( bind.world.rot );		// Then we apply it to the TBone Rotation, this will do a FWD Swing which will create
										// a new Up direction based on only swing.
		let swing_up	= Vec3.transform_quat( Vec3.UP, swing ),
			twist		= Vec3.angle( swing_up, pose_up );		// Swing + Pose have same Fwd, Use Angle between both UPs for twist

		/* VISUAL DEBUG SWING AND ANIMATED POSE DIRECTIONS 
		let pos 		= pose.world.pos.clone().add( [0,0,0.1] );
		let swing_fwd	= Vec3.transform_quat( Vec3.FORWARD, swing );
		App.Debug.ln( pos, Vec3.scale( pose_fwd, 1.5 ).add( pos ), "white" );	// Out Swing FWD Matches Animated Pose Forward
		App.Debug.ln( pos, Vec3.scale( swing_fwd, 1.3 ).add( pos ), "orange" );
		App.Debug.ln( pos, Vec3.scale( pose_up, 1.5 ).add( pos ), "white" );	// Now we see the TPose Up Direction in its Swing Rotation
		App.Debug.ln( pos, Vec3.scale( swing_up, 1.5 ).add( pos ), "orange" );	// Both UPs share the same forward, resulting in a "Twist" Difference.
		*/

		if( twist <= (0.01 * Math.PI / 180) ){
			twist = 0; // If Less the .01 Degree, dont bother twisting.
		}else{
			// The difference between Pose UP and Swing UP is what makes up our twist since they both
			// share the same forward access. The issue is that we do not know if that twist is in the Negative direction
			// or positive. So by computing the Swing Left Direction, we can use the Dot Product to determine
			// if swing UP is Over 90 Degrees, if so then its a positive twist else its negative.
			let swing_lft = Vec3.cross( swing_up, pose_fwd );
			// App.Debug.ln( pos, Vec3.scale( swing_lft, 1.5 ).add( pos ), "orange" );
			if( Vec3.dot( swing_lft, pose_up ) >= 0 ) twist = -twist; 
		}

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// Save all the info we need to our IK Pose.
		ik_pose.hip.bind_height	= bind.world.pos.y;	// The Bind Pose Height of the Hip, Helps with scaling.
		ik_pose.hip.movement.from_sub( pose.world.pos, bind.world.pos );	// How much movement did the hip do between Bind and Animated.
		ik_pose.hip.dir.copy( pose_fwd );	// Pose Forward is the direction we want the Hip to Point to.
		ik_pose.hip.twist = twist;	// How Much Twisting to Apply after pointing in the correct direction.
	}
}

// How to visualize the IK Pose Informaation to get an Idea of what we're looking at.
class IKVisualize{
	static run( e, ik ){
		let rig = e.IKRig;
		this.hip( rig, ik );
	}

	static hip( rig, ik ){
		let ws = rig.pose.bones[ rig.points.hip.idx ].world;
		App.Debug
			.pnt( ws.pos, "orange", 0.07, 6 )
			.ln( ws.pos, Vec3.scale( ik.hip.dir, 0.20 ).add( ws.pos ), "cyan", null, true );
	}
}

// #endregion ///////////////////////////////////////////

</script><page-layout></page-layout>