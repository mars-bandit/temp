<!DOCTYPE html><script type="module">
import App, {THREE}	from "../../fungi.3js/App.js";
import Vec3			from "../../fungi/maths/Vec3.js";


//#####################################################
App.builder( true )
	.set_camera( 0, 20, 4.0, 0, 0.35, 0 )
	.add( init )
	.render_on_mouse()
	.build();

let gSpline;


//#####################################################
async function init(){

	gSpline = new Spline( Hermite, true );
	//gSpline = new Spline( BezierCubic, false );

	gSpline
		.add( [-1.5,1,-1.5],	{ tension:0, bias:0 } )
		.add( [-0.8,0.2,1.2],		{ tension:0, bias:0 } )
		.add( [1.4,0.5,1],		{ tension:0, bias:0 } )
		.add( [0.5,0,-0.5],		{ tension:0, bias:0 } );

	gSpline.at( 0.51 );


	out_pnts( gSpline );
	out_path( gSpline, 30 );

	let map = new SplineLenMap( gSpline );

	out_map( gSpline, map );

	return true;
}

function out_pnts( s ){
	for( let p of s.points ){
		App.Debug.pnt( p.pos, 0x00ffff, 2, 15 );
	}
}

function out_path( s, samp=10 ){
	let t, v0 = new Vec3(), v1 = new Vec3();

	s.at( 0, v0 );
	App.Debug.pnt( v0, 0xff0000, 2, 5 );

	for( let i=1; i <= samp; i++ ){
		t = i / samp;
		s.at( t, v1 );


		App.Debug.ln( v0, v1 );
		//App.Debug.pnt( v1, 0xff0000, 2, 5 );

		v0.copy( v1 );
	}
}

function out_map( s, m, samp=10 ){
	let t,tt, v = new Vec3(), d = new Vec3(), dd = new Vec3();

	for( let i=0; i <= samp; i++ ){
		t = i / samp;
		tt = m.at( t );
		
		s.at( tt, v );
		s.dxdy( tt, d ).norm();

		App.Debug
			.pnt( v, 0x00ff00, 1, 5 )
			.ln( v, dd.from_scale( d, 0.3 ).add( v ), 0x00ff00 );
	}
}


class Spline{
	points 	= new Array();
	curve 	= null;
	is_loop = false;

	constructor( c, is_loop=false ){
		this.curve		= c;
		this.is_loop	= is_loop;
	}

	add( p, data=null ){
		this.points.push({
			pos 	: new Vec3( p ),
			data 	: data,
		});
		return this;
	}

	at( t, out ){
		out = out || new Vec3();

		let info = this.curve.spline_t( t, this.points.length, this.is_loop );
		this.curve.at( info, this.points, out );

		return out;
	}

	dxdy( t, out ){
		out = out || new Vec3();

		let info = this.curve.spline_t( t, this.points.length, this.is_loop );
		this.curve.dxdy( info, this.points, out );

		return out;
	}
}

function mod( a, b ){ let v = a % b; return ( v < 0 )? b+v : v; } // Modulas that handles Negatives, so (-1, 5) = 4


class Hermite{
	static at( info, pnts, out ){
		let t 	= info.t,
			ti 	= 1 - t,
			t2	= t * t,
			t3	= t2 * t,
			a0	= 2*t3 - 3*t2 + 1,
			a1	= t3 - 2*t2 + t,
			a2	= t3 - t2,
			a3	= -2*t3 + 3*t2;

		let a = pnts[ info.a ].pos,
			b = pnts[ info.b ].pos,
			c = pnts[ info.c ].pos,
			d = pnts[ info.d ].pos;

		let b_tension 	= pnts[ info.b ].data.tension || 0, 
			c_tension 	= pnts[ info.c ].data.tension || 0, 
			b_bias		= pnts[ info.b ].data.bias || 0,
			c_bias		= pnts[ info.c ].data.bias || 0;

		let tension	= b_tension * ti	+ c_tension * t,	// Lerp Tension between Points
			bias 	= b_bias * ti		+ c_bias * t,		// Lerp Bias between Points
			tb_n 	= ( 1 - bias) * ( 1 - tension ) * 0.5,
			tb_p 	= ( 1 + bias) * ( 1 - tension ) * 0.5;

		out[0] = a0*b[0] + a1 * ( (b[0]-a[0]) * tb_p + (c[0]-b[0]) * tb_n ) + a2 * ( (c[0]-b[0]) * tb_p + (d[0]-c[0]) * tb_n ) + a3*c[0];
		out[1] = a0*b[1] + a1 * ( (b[1]-a[1]) * tb_p + (c[1]-b[1]) * tb_n ) + a2 * ( (c[1]-b[1]) * tb_p + (d[1]-c[1]) * tb_n ) + a3*c[1];
		out[2] = a0*b[2] + a1 * ( (b[2]-a[2]) * tb_p + (c[2]-b[2]) * tb_n ) + a2 * ( (c[2]-b[2]) * tb_p + (d[2]-c[2]) * tb_n ) + a3*c[2];
		return out;
	}

	static dxdy( info, pnts, out ){
		let t 	= info.t,
			ti 	= 1 - t,
			tt  = t * t,
			tt6 = 6 * tt,
			tt3 = 3 * tt,
			a0  = tt6 - 6*t,
			a1  = tt3 - 4*t + 1,
			a2  = tt3 - 2*t,
			a3  = 6*t - tt6;

		let a = pnts[ info.a ].pos,
			b = pnts[ info.b ].pos,
			c = pnts[ info.c ].pos,
			d = pnts[ info.d ].pos;

		let b_tension 	= pnts[ info.b ].data.tension || 0, 
			c_tension 	= pnts[ info.c ].data.tension || 0, 
			b_bias		= pnts[ info.b ].data.bias || 0,
			c_bias		= pnts[ info.c ].data.bias || 0;

		let tension	= b_tension * ti	+ c_tension * t,	// Lerp Tension between Points
			bias 	= b_bias * ti		+ c_bias * t,		// Lerp Bias between Points
			tb_n 	= ( 1 - bias) * ( 1 - tension ) * 0.5,
			tb_p 	= ( 1 + bias) * ( 1 - tension ) * 0.5;

		out[0] = a0 * b[0] + a1 * ( (b[0]-a[0]) * tb_p  + (c[0]-b[0]) * tb_n ) + a2 * ( (c[0]-b[0]) * tb_p  + (d[0]-c[0]) * tb_n ) + a3 * c[0];
		out[1] = a0 * b[1] + a1 * ( (b[1]-a[1]) * tb_p  + (c[1]-b[1]) * tb_n ) + a2 * ( (c[1]-b[1]) * tb_p  + (d[1]-c[1]) * tb_n ) + a3 * c[1];
		out[2] = a0 * b[2] + a1 * ( (b[2]-a[2]) * tb_p  + (c[2]-b[2]) * tb_n ) + a2 * ( (c[2]-b[2]) * tb_p  + (d[2]-c[2]) * tb_n ) + a3 * c[2];
		return out;
	}

	static spline_t( t, point_cnt, is_loop=false ){
		let i, tt, ti, ai, bi, ci, di;

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// Figure out the starting index of the curve and the time on the curve.
		if( t > 1 ) 		t = 1;
		else if( t < 0 )	t = 0;

		if( is_loop ){
			if( t != 1 ){
				tt = t * point_cnt;
				i  = tt | 0;
				tt -= i;	
			}else{
				i	= point_cnt - 1;
				tt	= 1;
			}	

			ti = 1 - tt;
			ai = mod( i-1, point_cnt );
			bi = i;
			ci = mod( i+1, point_cnt );
			di = mod( i+2, point_cnt );
		}else{ 								// Determine which curve is being accessed
			if( t != 1 ){
				tt	= t * (point_cnt - 3) 	// curve_cnt = point_cnt-3
				i 	= tt | 0;				// Curve index by stripping out the decimal, BitwiseOR 0 same op as Floor
				tt	-= i;					// Strip out the whole number to get the decimal norm to be used for the curve ( FRACT )
			}else{
				i	= point_cnt - 4;
				tt	= 1;
			}

			ti 	= 1 - tt;	// Time Inverse	
			ai 	= i;
			bi 	= i + 1;
			ci	= i + 2;
			di	= i + 3;
		}

		return { t:tt, a:ai, b:bi, c:ci, d:di };
	}
}


class BezierCubic{
	static at( info, pnts, out ){
		let t 	 	= info.t,
			i		= 1 - t,
			ii		= i * i,
			iii		= ii * i,
			tt 		= t * t,
			ttt 	= tt * t,
			iit3 	= 3 * ii * t,
			itt3 	= 3 * i * tt;

		let a = pnts[ info.a ].pos,
			b = pnts[ info.b ].pos,
			c = pnts[ info.c ].pos,
			d = pnts[ info.d ].pos;

		out[0] = iii * a[0] + iit3 * b[0] + itt3 * c[0] + ttt * d[0];
		out[1] = iii * a[1] + iit3 * b[1] + itt3 * c[1] + ttt * d[1];
		out[2] = iii * a[2] + iit3 * b[2] + itt3 * c[2] + ttt * d[2];
		return out;
	}

	static dxdy( info, pnts, out){
		let t 	= info.t,
			i	= 1 - t,
			ii3	= 3 * i * i,
			it6	= 6 * i * t,
			tt3	= 3 * t * t;

		let a = pnts[ info.a ].pos,
			b = pnts[ info.b ].pos,
			c = pnts[ info.c ].pos,
			d = pnts[ info.d ].pos;

		out[0] = ii3 * (b[0] - a[0])  +  it6 * (c[0] - b[0])  +  tt3 * (d[0] - c[0]);
		out[1] = ii3 * (b[1] - a[1])  +  it6 * (c[1] - b[1])  +  tt3 * (d[1] - c[1]);
		out[2] = ii3 * (b[2] - a[2])  +  it6 * (c[2] - b[2])  +  tt3 * (d[2] - c[2]);

		return out;
	}

	static spline_t( t, point_cnt, is_loop=false ){
		let i, a, b, c, d;
		if( is_loop ){
			if( t >= 1 ){ t = 1; a = point_cnt-1; b = point_cnt-2; c = 1; d = 0; }
			else if( t <= 0 ){ t = 0; a = 0; b = 1; c = 2; d = 3; }
			else{
				let curve_cnt = Math.round( (point_cnt - 1) * 0.33333333333 );
				t *= ( point_cnt + 2 ) * 0.33333333333;
				i = t | 0;	//Floor value
				t -= i;		// Fract

				if( i == curve_cnt ){ a = point_cnt-1; b = point_cnt-2; c = 1; d = 0; }
				else{
					i *= 3;
					a = i; b = i+1; c = i+2; d = i+3;
				}
			}
		}else{
			if(t >= 1){
				t = 1;
				i = point_cnt - 4;
			}else if( t <= 0 ){
				t = 0;
				i = 0;
			}else{ //Determine which curve is being accessed.
				if(t < 0) t = 0;
				t *= (point_cnt - 1) * 0.33333333333; // divide by 3
				i = t | 0;				// Curve index by stripping out the decimal
				t -= i;					// Strip out the whole number to get the decimal norm to be used for the curve ( FRACT )
				i *= 3;					// Each curve starts at the 4th point in the array, so times 3 gets us the index where the curve starts.	
			}

			a = i; b = i+1; c = i+2; d = i+3;
		}

		return { t, a, b, c, d };
	}
}


class SplineLenMap{
	arc_len		= 0;	// Total Length of the Spline
	samp_cnt 	= 0;	// Total Samples
	len_ary 	= null;	// Total length at each sample 
	inc_ary 	= null;	// Length Traveled at each samples
	time_ary 	= null; // Curve T Value at each samples

	constructor( s=null, samp_cnt=10 ){
		if( s ) this.from_spline( s, samp_cnt );
	}

	from_spline( s, samp_cnt=20 ){
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		this.len_ary 	= new Array( samp_cnt );
		this.inc_ary	= new Array( samp_cnt );
		this.time_ary	= new Array( samp_cnt );
		this.samp_cnt 	= samp_cnt;

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		let v0	= new Vec3(),
			v1	= new Vec3(),
			max	= samp_cnt - 1,
			len, t;

		s.at( 0, v0 );
		this.len_ary[ 0 ]	= 0;
		this.inc_ary[ 0 ]	= 0;
		this.time_ary[ 0 ]	= 0;

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		for( let i=1; i <= max; i++ ){
			t = i / max;
			s.at( t, v1 );

			//.................................
			len 				= Vec3.len( v0, v1 );
			this.arc_len		+= len;					// Total Length
			this.len_ary[ i ]	= this.arc_len;			// Current Total Length
			this.inc_ary[ i ]	= len;					// Length between Current+Previous Point
			this.time_ary[ i ]	= t;					// Time Curve Step

			//.................................
			v0.copy( v1 );
		}

		return this;
	}

	at( t ){
		if( t >= 1 ) return 1;
		if( t <= 0 ) return 0;

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		let i, t_len = this.arc_len * t;

		for( i=this.samp_cnt-1; i >= 0; i-- ){	// Search for first length SMALLER then the searching one
			if( this.len_ary[ i ] < t_len ){				
				let tt = ( t_len - this.len_ary[ i ] ) / this.inc_ary[ i+1 ]; 	// Normalize the Search Length   ( x-a / b-a )
				return this.time_ary[ i ] * (1-tt) + this.time_ary[ i+1 ] * tt;	// Interpolate the Curve Time between two points
			}
		}

		return 0;
	}
}


class CurveLenMap{
	constructor( c=null, samp_cnt=20 ){
		this.len_array		= null;	// Total length at each sample step
		this.len_inc_array	= null;	// Length Traveled per step
		this.time_array		= null;	// Curve T Value at each step
		this.arc_len		= 0;	// Total Arc Length
		this.samp_cnt		= 0;	// How Many samples taken.

		if( c ) this.from_curve( c, samp_cnt );
	}

	from_curve( c, samp_cnt=20 ){
		this.len_array		= new Array( samp_cnt );
		this.len_inc_array	= new Array( samp_cnt );
		this.time_array		= new Array( samp_cnt );
		this.arc_len		= 0;
		this.samp_cnt		= samp_cnt;

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		let max 	= samp_cnt - 1,
			max_inv	= 1 / max,
			prev_p	= [ 0, 0, 0 ],
			curr_p 	= [ 0, 0, 0 ],
			i, t, len;

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		c.at( 0, prev_p );
		this.len_array[0]		= 0;
		this.time_array[0]		= 0;

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		for( i=1; i <= max; i++ ){
			t = i * max_inv;
			c.at( t, curr_p );

			//......................................
			// Length Traveled since prevous point.
			len = Math.sqrt(
				( prev_p[0] - curr_p[0] ) ** 2 +
				( prev_p[1] - curr_p[1] ) ** 2 +
				( prev_p[2] - curr_p[2] ) ** 2 );

			this.arc_len 				+= len;
			this.len_inc_array[ i-1 ]	= len;
			this.len_array[ i ]			= this.arc_len;
			this.time_array[ i ]		= t;

			//......................................
			prev_p[0] = curr_p[0];
			prev_p[1] = curr_p[1];
			prev_p[2] = curr_p[2];
		}

		return this;
	}

	get( t ){
		if( t >= 1 ) return 1;
		if( t <= 0 ) return 0;

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		let i, t_len = this.arc_len * t;

		for( i=this.samp_cnt-1; i >= 0; i-- ){	// Search for first length SMALLER then the searching one
			if( this.len_array[i] < t_len ){
				let tt = ( t_len - this.len_array[ i ] ) / this.len_inc_array[ i ], // Normalize the Search Length
					ti = 1 - tt;
				return this.time_array[ i ] * ti + this.time_array[ i+1 ] * tt;		// Lerp Between this sample time and the next one.
			}
		}

		return 0;
	}
}


</script><page-layout></page-layout>