<!DOCTYPE html><script type="module">
import App				from "../../fungi/App.js";

import XhrQueue 		from "../../fungi/lib/XhrQueue.js";
import GltfUtil	        from "../../fungi/lib/GltfUtil.js";
import IKRig			from "../../fungi.armature/IKRig.js";

import Motion			from "../../fungi.test/Motion.js";

//#####################################################

App.builder( true, true )
	.use_armature()
	.load_shaders( "../fungi.armature/LowPolySkin.js" )
	//.set_camera( 40, 20, 2.0, 0, 0.7, 0 )
	.set_camera( 135, 25, 3, -0.2, 0.7, 0 )
	.add( init )
	.render_loop( on_draw )
	//.render_on_mouse()
	.build();

//#####################################################

let gModel, gMotion;
function on_draw( dt, ss ){
	gMotion( dt );
	// TODO may need to revamp armature systems, Merge Bone+Armature,
	// then if Node.updated && !Armature.updated, make Arm Updated to not 
	// need to do this.
	gModel.Armature.updated = true;

	//RigSpringSys( App.ecs );
	SpringRigSys( App.ecs );
}

async function init(){
	let dl = await XhrQueue
		.url( "../../_tmp/" )
		.grp( "rex", "robo_trex.gltf", "json", "robo_trex.bin", "bin" )
		.then();

	if( dl.rex ) load_mesh( dl.rex.json, dl.rex.bin );

	
	//RigSpringSys( App.ecs );
	/*
	App.delta_time = 0.001;
	gModel.Node.set_pos( -0.5, 0, 0 );

	RigSpringSys( App.ecs );
	*/

	/*
	SpringRigSys( App.ecs );
	App.delta_time = 0.001;
	gModel.Node.set_pos( -0.5, 0, 0 );
	SpringRigSys( App.ecs );
	*/

	gMotion = Motion.sin( gModel, 1.0, [1,0.0,0] );

	return true;
}

//#####################################################

function load_mesh( json, bin ){	
	let mat		= App.new_mat( "LowPolySkin", {color:"#ffffff"} );
	let e		= GltfUtil.get_debug_view( "target_b", json, bin, mat );
	//let e		= GltfUtil.get_bone_view( "target_b", json, bin );
	let rig 	= e
		.add_com( "IKRig" )
		.init( null, false, 0 )

		.add_point( "wing_l", "left_wing" )
		.add_point( "wing_r", "right_wing" )

		//.add_point( "hip", "hip" )
		//.add_point( "head", "face_joint" )
		//.add_point( "foot_l", "LeftFoot" )
		//.add_point( "foot_r", "RightFoot" )

		//.add_chain( "leg_r", [ "RightUpLeg", "RightKnee", "RightShin" ], "z", "RightFoot", "three_bone" )
		//.add_chain( "leg_l", [ "LeftUpLeg", "LeftKnee", "LeftShin" ], "z", "LeftFoot", "three_bone" )
		//.add_chain( "spine", [ "Spine", "Spine1" ] )
		.add_chain( "tail", ["tail_1","tail_2","tail_3","tail_4","tail_5","tail_6","tail_7"] )
		//.set_leg_lmt( null, -0.1 )
	;
	
	//let rs	= e.add_com( "RigSpring" );
	//rs.use_chain_semi( "tail", 0.9, -0.1, 0.9 );
	//rs.use_point_semi( "wing_l", 0.1, 0.1 );
	//rs.use_point_semi( "wing_r", 0.1, 0.1 );

	
	let rs	= e.add_com( "SpringRig" );
	rs.add( rig.get_chain_indices( "tail" ), 0.9, 0.9, -0.1 );
	rs.add( rig.points.wing_l.idx, 1.0, 0.2 );
	rs.add( rig.points.wing_r.idx, 1.0, 0.2 );

	//rs.add( rig.points.wing_r.idx, { type:"tension", tension:2, damp:5 } );

	//console.log( rs );

	//e.Node.set_pos( -1.0, 0.5, 0 );
	gModel = e;
}

//#####################################################

import { Vec3, Quat, Transform } from "../../fungi/maths/Maths.js";
import Axis from "../../fungi/maths/Axis.js";

class RigSpring{
	constructor(){
		this.chains 	= new Array();
		this.points 	= new Array();
		this.do_reset 	= true; // If true, reset All targets, positions with current pose, clear vel
	}

	use_chain_semi( ch_name, damp=0.5, damp_inc=0.1, osc=1, osc_inc=0 ){
        let o = { items: new Array() };
        let rig = App.get_e( this.entity_id ).IKRig;
        let ch = rig.chains[ ch_name ];

        for( let i = 0; i < ch.cnt; i++ ){
            o.items.push({ 
                idx		: ch.bones[ i ].idx,
                spring	: new SemiImplicitEuler( osc + osc_inc * i, damp + damp_inc * i ),
            });
        }

		this.chains.push( o );
		return this;
	}

	use_point_semi( pnt_name, damp=0.5, osc=1 ){
        let rig = App.get_e( this.entity_id ).IKRig;
		let pnt = rig.points[ pnt_name ];
		
		this.points.push({ 
		    idx		: pnt.idx,
			spring	: new SemiImplicitEuler( osc, damp ),
        });
		return this;
	}

	use_point_tension( pnt_name, tension=2.0, damp=1.2 ){
        let rig = App.get_e( this.entity_id ).IKRig;
		let pnt = rig.points[ pnt_name ];
		
		this.points.push({ 
		    idx		: pnt.idx,
			spring	: new TensionSpring( tension, damp ),
        });
		return this;
	}


	reset_all(){
		console.log( "reset all" );
		let rig	= App.get_e( this.entity_id ).IKRig,
			pt	= new Transform(),
			pos = new Vec3(),
			i, j, b, ch;

		for( i=0; i < this.chains.length; i++ ){
			ch 	= this.chains[ i ];					// Get Chain
			b 	= rig.arm.bones[ ch.items[0].idx ];	// Root Bone

			//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			// Compute Parent's World Space Transform
			if( b.ref.Node.parent )
				b.ref.Node.parent.Node.get_world_transform( pt );
			else pt.clear();
			
			//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			for( j=0; j < ch.items.length; j++ ){
				b = rig.arm.bones[ ch.items[ j ].idx ]; // Get Bone
				
				// Use Bones local to compute ws, then again
				// to compute tail position
				pos.set( 0, b.len, 0 );
				pt.add( b.local ).transform_vec( pos );

				// Save resting position to spring
				//ch.items[ j ].spring.reset( ct.pos );
				ch.items[ j ].spring.reset( pos );
				//App.Debug.pnt( ch.items[ j ].spring.pos, "red" );
			}
		}

		for( i=0; i < this.points.length; i++ ){
			ch	= this.points[ i ];
			b	= rig.arm.bones[ ch.idx ];
			b.ref.Node.get_world_transform( pt );
			pos.set( 0, b.len, 0 );
			pt.transform_vec( pos );

			ch.spring.reset( pos );
		}


		this.do_reset = false; // Reset complete
		return this;
	}


	update( dt ){
		let rig		= App.get_e( this.entity_id ).IKRig,
			pt		= new Transform(),
			ct		= new Transform(),
			tail	= new Vec3(),
			ray_a 	= new Vec3(),
			ray_b 	= new Vec3(),
			rot 	= new Quat(),
			i, j, b, ch, itm, s_pos;

		for( i=0; i < this.chains.length; i++ ){
			ch 	= this.chains[ i ];					// Get Chain
			b 	= rig.arm.bones[ ch.items[0].idx ];	// Root Bone Node

			//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			// Compute Parent's World Space Transform
			if( b.ref.Node.parent )
				b.ref.Node.parent.Node.get_world_transform( pt );
			else pt.clear();
			
			//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			for( j=0; j < ch.items.length; j++ ){
				itm 	= ch.items[ j ];			// Get our bone spring
				b		= rig.arm.bones[ itm.idx ]; // Get Bone Object ( use .ref for entity )
				
				//---------------------------
				// Use Bones local to compute ws, then again
				// to compute tail position
				tail.set( 0, b.len, 0 );
				ct.from_add( pt, b.local ).transform_vec( tail );

				///App.Debug.pnt( tail, "green" );

				//---------------------------
				s_pos = itm.spring.update( dt, tail );			// Pass updated target to spring and update

				ray_a.from_sub( tail, ct.pos ).norm();			// Ray to Resting position
				ray_b.from_sub( s_pos, ct.pos ).norm();			// and to spring pos

				rot .from_unit_vecs( ray_a, ray_b )				// Create Rotation based on Rays
					.mul( ct.rot )								// Apply it to WS Bind Transfrom
					.pmul_invert( pt.rot );						// Convert it to local Space

				//---------------------------
				b.ref.Node.set_rot( rot );							// Save Results
				//pose.set_bone( bone.idx, rot );					
				pt.add( rot, b.local.pos, b.local.scl );		// Use new rotation to build the next parent ws transform for next bone
			}
		}

		for( i=0; i < this.points.length; i++ ){
			ch	= this.points[ i ];
			b	= rig.arm.bones[ ch.idx ];

			if( b.ref.Node.parent )
				b.ref.Node.parent.Node.get_world_transform( pt );
			else pt.clear();

			//---------------------------
			// Use Bones local to compute ws, then again
			// to compute tail position
			tail.set( 0, b.len, 0 );
			ct.from_add( pt, b.local ).transform_vec( tail );

			//---------------------------
			s_pos = ch.spring.update( dt, tail );			// Pass updated target to spring and update

			ray_a.from_sub( tail, ct.pos ).norm();			// Ray to Resting position
			ray_b.from_sub( s_pos, ct.pos ).norm();			// and to spring pos

			rot .from_unit_vecs( ray_a, ray_b )				// Create Rotation based on Rays
				.mul( ct.rot )								// Apply it to WS Bind Transfrom
				.pmul_invert( pt.rot );						// Convert it to local Space

			//---------------------------
			b.ref.Node.set_rot( rot );	
		}

		return this;

		/*
			let pt			= new Transform(),
				ct			= new Transform(),
				tail_pos	= new Vec3(),
				ray_a		= new Vec3(),
				ray_b		= new Vec3(),
				rot			= new Quat(),
				bone, i, s_pos;

			// Set the Starting Parent World Transform
			bone = pose.bones[ this.nodes[0].idx ];
			pt.copy( pose.bones[ bone.p_idx ].world );

			for( i of this.nodes ){
				bone = bind.bones[ i.idx ];		// Get Bone

				ct.from_add( pt, bone.local );	// Calc is World Space Transform
				
				tail_pos.set( 0, bone.len, 0 );	// Calc the Bone Tail BIND World Transform, this is our target point
				ct.transform_vec( tail_pos );

				// Pass updated target to spring and update
				s_pos = i.spring.set_target( tail_pos ).update( dt );
				

				ray_a.from_sub( tail_pos, ct.pos ).norm();		// Create Ray to spring position
				ray_b.from_sub( s_pos, ct.pos ).norm();			// And to Target

				rot .from_unit_vecs( ray_a, ray_b )				// Create Rotation based on Rays
					.mul( ct.rot )								// Apply it to WS Bind Transfrom
					.pmul_invert( pt.rot );						// Convert it to local Space

				pose.set_bone( bone.idx, rot );					// Save Results
				pt.add( rot, bone.local.pos, bone.local.scl );	// Use new rotation to build the next parent ws transform for next bone
			}

			pose.apply();
			*/

	}
} App.Components.reg( RigSpring );

function RigSpringSys( ecs ){
	let n, ary = ecs.query_comp( "RigSpring" );
	for( n of ary ){
		if( n.do_reset )	n.reset_all();
		else 				n.update( App.delta_time );
	}
}


class SemiImplicitEuler{
	constructor( osc=1, damp=1, damp_time=0 ){
		this.vel = new Vec3();
		this.pos = new Vec3();
		this.tar = new Vec3();

		// Damp_ratio = Log(damp) / ( -osc_ps * damp_time ) 
		// Damp Time, in seconds to damp. So damp 0.5 for every 2 seconds.
		// Damp needs to be a value between 0 and 1, if 1, creates critical damping.
		this.osc_ps 	= Math.PI * 2 * osc;
		if( damp_time )	this.damping = Math.log( damp ) / ( -this.osc_ps * damp_time );
		else 			this.damping = damp;
	}

	static from_config( c, inc=null ){
		return ( inc != null )?
			new SemiImplicitEuler( c.osc + (c.osc_inc || 0) * inc, c.damp + (c.damp_inc || 0) * inc ) :
			new SemiImplicitEuler( c.osc , c.damp );
	}

	reset( pos=null, tar=null, vel=null ){
		if( pos ) 	this.pos.copy( pos );
		else 		this.pos.set( 0,0,0 );

		if( tar ) 	this.tar.copy( tar );
		else 		this.tar.set( 0,0,0 );

		if( vel )	this.vel.copy( vel );
		else		this.vel.set( 0,0,0 );

		return this;
	}

	set_target( p ){ this.tar.copy( p ); return this; }
	update( dt, target_pos=null ){
		let a = -2.0 * dt * this.damping * this.osc_ps,
			b = dt * this.osc_ps * this.osc_ps;

		if( target_pos ) this.tar.copy( target_pos );

		// Compute Acceleration, Add it to Velocity
		this.vel[0] += ( a * this.vel[0] + b * ( this.tar[0] - this.pos[0] ) ); // * this.mass_inv;
		this.vel[1] += ( a * this.vel[1] + b * ( this.tar[1] - this.pos[1] ) ); // * this.mass_inv;
		this.vel[2] += ( a * this.vel[2] + b * ( this.tar[2] - this.pos[2] ) ); // * this.mass_inv;

		// Add Velocity to Position
		this.pos[0] += this.vel[0] * dt;
		this.pos[1] += this.vel[1] * dt;
		this.pos[2] += this.vel[2] * dt;
		return this.pos;
	}
}

class TensionSpring{
	constructor( t=2.0, d=1.2 ){
		this.vel = new Vec3();
		this.pos = new Vec3();
		this.tar = new Vec3();

		this.tension = t;
		this.damping = d;
		//this.mass		= 1;
		//this.mass_inv	= 1 / this.mass;	// a = f / m OR a = f * m_inv
	}

	reset( pos=null, tar=null, vel=null ){
		if( pos ) 	this.pos.copy( pos );
		else 		this.pos.set( 0,0,0 );

		if( tar ) 	this.tar.copy( tar );
		else 		this.tar.set( 0,0,0 );

		if( vel )	this.vel.copy( vel );
		else		this.vel.set( 0,0,0 );

		return this;
	}
	
	//{ type:"tension", tension:2.0, damp:1.2, tension_inc:0, damp_inc:0 }
	static from_config( c, inc=null ){
		return ( inc != null )?
			new TensionSpring( c.tension + (c.tension_inc || 0) * inc, c.damp + (c.damp_inc || 0) * inc ) :
			new TensionSpring( c.tension , c.damp );
	}


	set_target( p ){ this.tar.copy( p ); return this; }
	update( dt, target_pos=null ){
		if( target_pos ) this.tar.copy( target_pos );

		// Compute Acceleration, Add it to Velocity
		let ax	= -this.tension * ( this.pos[0] - this.tar[0] ), // * this.mass_inv,
			ay	= -this.tension * ( this.pos[1] - this.tar[1] ), // * this.mass_inv,
			az	= -this.tension * ( this.pos[2] - this.tar[2] ); // * this.mass_inv;

		this.vel[0] += ( ax - this.damping * this.vel[0] ) * dt;
		this.vel[1] += ( ay - this.damping * this.vel[1] ) * dt;
		this.vel[2] += ( ay - this.damping * this.vel[2] ) * dt;

		// Add Velocity to Position
		this.pos[0] += this.vel[0] * dt;
		this.pos[1] += this.vel[1] * dt;
		this.pos[2] += this.vel[2] * dt;
		return this.pos;
	}
}


class SpringRig{
	constructor(){
		this.sets		= new Array();
		this.do_reset	= true;
	}

	add( idx_ary, osc=1.0, damp=0.9, damp_inc=0, osc_inc=0){
		let i, o = { bones : new Array() };

		// If only passing in a single bone index, turn it into an array.
		if( !Array.isArray( idx_ary ) ) idx_ary = [ idx_ary ];

		for( i=0; i < idx_ary.length; i++ ){
			o.bones.push( { 
				idx		: idx_ary[ i ], 
				spring	: new SemiImplicitEuler( osc + osc_inc * i, damp + damp_inc * i ), 
			});
		}

		this.sets.push( o );
		return this;
	}

	reset_all(){
		//console.log( "reset all" );
		let rig	= App.get_e( this.entity_id ).IKRig,
			pt	= new Transform(),
			pos = new Vec3(),
			i, sb, b, s;

		for( i=0; i < this.sets.length; i++ ){
			s 	= this.sets[ i ];					// Get Bone Set
			b 	= rig.arm.bones[ s.bones[0].idx ];	// Root Bone

			//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			// Compute Parent's World Space Transform
			if( b.ref.Node.parent )
				b.ref.Node.parent.Node.get_world_transform( pt );
			else pt.clear();
			
			//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			for( sb of s.bones ){
				b = rig.arm.bones[ sb.idx ]; // Get Bone
				
				pt.add( b.local )
					.transform_vec( pos.set( 0, b.len, 0 ) );	// Use Bones local to compute, Then transform Tail Position
				
				sb.spring.reset( pos );	// Save resting position to spring
				//App.Debug.pnt( sb.spring.pos, "red" );
			}
		}

		this.do_reset = false;
		return this;
	}

	update( dt ){
		let rig		= App.get_e( this.entity_id ).IKRig,
			pt		= new Transform(),
			ct		= new Transform(),
			tail	= new Vec3(),
			ray_a 	= new Vec3(),
			ray_b 	= new Vec3(),
			rot 	= new Quat(),
			i, b, s, sb, s_pos;

		for( i=0; i < this.sets.length; i++ ){
			s 	= this.sets[ i ];					// Get Bone Set
			b 	= rig.arm.bones[ s.bones[0].idx ];	// Root Bone Node

			//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			// Compute Parent's World Space Transform
			if( b.ref.Node.parent )
				b.ref.Node.parent.Node.get_world_transform( pt );
			else pt.clear();
			
			//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			for( sb of s.bones ){
				b = rig.arm.bones[ sb.idx ]; 		// Get Bone Object ( use .ref for entity )
				
				//---------------------------
				// Compute ws for the bone, then using it to get ws tail position
				tail.set( 0, b.len, 0 )
				ct.from_add( pt, b.local ).transform_vec( tail );

				///App.Debug.pnt( tail, "green" );

				//---------------------------
				s_pos = sb.spring.update( dt, tail );			// Pass updated target to spring and update

				ray_a.from_sub( tail, ct.pos ).norm();			// Ray to Resting position
				ray_b.from_sub( s_pos, ct.pos ).norm();			// and to spring pos

				rot .from_unit_vecs( ray_a, ray_b )				// Create Rotation based on Rays
					.mul( ct.rot )								// Apply it to WS Bind Transfrom
					.pmul_invert( pt.rot );						// Convert it to local Space

				//---------------------------
				b.ref.Node.set_rot( rot );						// Save Results
				//pose.set_bone( bone.idx, rot );					
				pt.add( rot, b.local.pos, b.local.scl );		// Use new rotation to build the next parent ws transform for next bone
			}
		}

		return this;
	}
} App.Components.reg( SpringRig );


function SpringRigSys( ecs ){
	let n, ary = ecs.query_comp( "SpringRig" );
	for( n of ary ){
		if( n.do_reset )	n.reset_all();
		else 				n.update( App.delta_time );
	}
}


// #region trash

class Vec3Spring{
	constructor( pos=null ){
		this.vel 		= new Vec3();
		this.pos 		= new Vec3();
		this.tar 		= new Vec3();

		this.mode 		= 0;	// Define which spring equation to use.
		this.osc_ps		= 0;	// used for semi-implicit euler
		this.tension	= 0;	
		this.damping	= 0;

		this.mass		= 1;
		this.mass_inv	= 1 / this.mass;	// a = f / m OR a = f * m_inv

		if( pos ) this.pos.copy( pos );
	}

	/////////////////////////////////////////////////////////////////
	// Setters
	/////////////////////////////////////////////////////////////////
		use_euler( osc=1, damp=1, damp_time=0 ){
			this.osc_ps = Math.PI * 2 * osc;

			// Damp_ratio = Log(damp) / ( -osc_ps * damp_time ) 
			// Damp Time, in seconds to damp. So damp 0.5 for every 2 seconds.
			// Damp needs to be a value between 0 and 1, if 1, creates critical damping.
			if( this.damp_time )	this.damping = Math.log( damp ) / ( -this.osc_ps * damp_time );
			else 					this.damping = damp;

			this.mode = 1;
			return this;
		}

		use_tension( tension=2.0, damp=1.2 ){
			this.tension	= tension;
			this.damping	= damp;
			this.mode		= 2;
			return this;
		}

		set_mass( m ){ this.mass = m; this.mass_inv = 1 / this.mass; return this; }
		set_pos( p ){ this.pos.copy( p ); return this; }
		set_target( p ){ this.tar.copy( p ); return this; }

		get_dir( s=1, out=null ){
			let mag = 1 / Math.sqrt( this.vel[0] ** 2 + this.vel[1] ** 2 + this.vel[2] ** 2 ) * s;

			out = out || new Vec3();
			return out.set( this.vel[0] * mag, this.vel[1] * mag, this.vel[2] * mag );
		}

	/////////////////////////////////////////////////////////////////
	//
	/////////////////////////////////////////////////////////////////
		update( dt ){
			switch( this.mode ){
				//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				// semi-implicit euler
				case 1: 
					let a = -2.0 * dt * this.damping * this.osc_ps,
						b = dt * this.osc_ps * this.osc_ps;

					this.vel[0] += ( a * this.vel[0] + b * ( this.tar[0] - this.pos[0] ) ) * this.mass_inv;
					this.vel[1] += ( a * this.vel[1] + b * ( this.tar[1] - this.pos[1] ) ) * this.mass_inv;
					this.vel[2] += ( a * this.vel[2] + b * ( this.tar[2] - this.pos[2] ) ) * this.mass_inv;
					break;

				//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				// Acceleration from Tension
				case 2: 
					let ax	= -this.tension * ( this.pos[0] - this.tar[0] ) * this.mass_inv,
						ay	= -this.tension * ( this.pos[1] - this.tar[1] ) * this.mass_inv,
						az	= -this.tension * ( this.pos[2] - this.tar[2] ) * this.mass_inv;

					this.vel[0] += ( ax - this.damping * this.vel[0] ) * dt;
					this.vel[1] += ( ay - this.damping * this.vel[1] ) * dt;
					this.vel[2] += ( ay - this.damping * this.vel[2] ) * dt;
					break;
			}

			this.pos[0] += this.vel[0] * dt;
			this.pos[1] += this.vel[1] * dt;
			this.pos[2] += this.vel[2] * dt;
			return this.pos;
		}
}

class ChainSpring{
	constructor( chain ){
		this.nodes = new Array( chain.cnt );

		let i;
		for( i=0; i < chain.cnt; i++ ){
			this.nodes[ i ] = {
				idx		: chain.bones[ i ],
				spring	: new Vec3Spring(),
			};
		}
	}

	/////////////////////////////////////////////////////////////////////
	// GETTERS - SETTERS
	/////////////////////////////////////////////////////////////////////	
		use_euler( damp=0.5, damp_inc=0.1, osc=1, osc_inc=0.2 ){
			let i;
			for( i=0; i < this.nodes.length; i++ ){
				this.nodes[ i ].spring.use_euler(  osc + osc_inc*i, damp + damp_inc * i );
			}
			return this;
		}

		set_pos( pose ){
			let i, b, pos = new Vec3();
			for( i of this.nodes ){
				b = pose.bones[ i.idx ];
				pos.set( 0, b.len, 0 );

				b.world.transform_vec( pos );
				i.spring.set_pos( pos );  // save trail position.

				//App.debug.point( pos,1 );
			}
			return this;
		}

	/////////////////////////////////////////////////////////////////////
	//
	/////////////////////////////////////////////////////////////////////	
		update( bind, pose, dt ){
			/*
			let pt			= new Transform(),
				ct			= new Transform(),
				tail_pos	= new Vec3(),
				ray_a		= new Vec3(),
				ray_b		= new Vec3(),
				rot			= new Quat(),
				bone, i, s_pos;

			// Set the Starting Parent World Transform
			bone = pose.bones[ this.nodes[0].idx ];
			pt.copy( pose.bones[ bone.p_idx ].world );

			for( i of this.nodes ){
				bone = bind.bones[ i.idx ];		// Get Bone

				ct.from_add( pt, bone.local );	// Calc is World Space Transform
				
				tail_pos.set( 0, bone.len, 0 );	// Calc the Bone Tail BIND World Transform, this is our target point
				ct.transform_vec( tail_pos );

				// Pass updated target to spring and update
				s_pos = i.spring.set_target( tail_pos ).update( dt );
				

				ray_a.from_sub( tail_pos, ct.pos ).norm();		// Create Ray to spring position
				ray_b.from_sub( s_pos, ct.pos ).norm();			// And to Target

				rot .from_unit_vecs( ray_a, ray_b )				// Create Rotation based on Rays
					.mul( ct.rot )								// Apply it to WS Bind Transfrom
					.pmul_invert( pt.rot );						// Convert it to local Space

				pose.set_bone( bone.idx, rot );					// Save Results
				pt.add( rot, bone.local.pos, bone.local.scl );	// Use new rotation to build the next parent ws transform for next bone
			}

			pose.apply();
			*/
		}
}


// #endregion
</script><page-layout></page-layout>