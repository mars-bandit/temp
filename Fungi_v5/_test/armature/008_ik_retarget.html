<!DOCTYPE html><script type="module">
import App				from "../../fungi/App.js";
import IKTarget 		from "../../fungi.armature/IKTarget.js";

import Animation		from "../../fungi/lib/Animation.js";
import PoseAnimator		from "../../fungi.armature/PoseAnimator.js";

import XhrPromise		from "../../fungi/lib/XhrPromise.js";
import GltfUtil, {Gltf}	from "../../fungi/lib/GltfUtil.js";
import IKRig			from "../../fungi.armature/IKRig.js";

//#####################################################

App.builder( true )
	.use_armature()
	.load_shaders( "../fungi.armature/LowPolySkin.js" )
	//.set_camera( 40, 20, 2.0, 0, 0.7, 0 )
	.set_camera( 0, 20, 3.5, 0, 0.7, 0 )
	.add( init )
	//.render_loop( on_draw )
	.render_on_mouse()
	.build();

//#####################################################

let gAnimate, gEntitySrc, gModelA, gModelB, gIKPose;
function on_draw( dt, ss ){
	gAnimate( dt );
}

async function init(){
	let dl = await XhrPromise.get( 
		"../../_tmp/walking.gltf", "json", 
		"../../_tmp/walking.bin", "arraybuffer",
		"../../files/models/vegeta.gltf", "json", 
		"../../files/models/vegeta.bin", "arraybuffer",
		//"../../_tmp/robo_trex.gltf", "json", 
		//"../../_tmp/robo_trex.bin", "arraybuffer",
	);

	gAnimate = load_src( dl[0], dl[1] );
	
	load_mesh_a( dl[2], dl[3] );
	//load_mesh_b( dl[4], dl[5] );

	gIKPose = new IKPose();
		
	//let b	= gEntitySrc.Armature.get_e( "LeftUpLeg" );
	//let wt	= b.Node.get_world_transform();
	//App.Debug.pnt( wt.pos, "red", 0.09 );
	//App.Debug.ln( wt.pos, Vec3.transform_quat( Vec3.BACK, wt.rot ).add( wt.pos ), "red" );

	gAnimate( 0.2 );

	
	/*
	complete_ik_pose( gEntitySrc, gIKPose );
	gIKPose.apply_rig( gModelA.IKRig );
	gModelA.IKRig.apply_pose();
	*/

	return true;
}

//#####################################################

function load_src( json, bin ){	
	//let mat		= App.new_mat( "LowPolySkin", {color:"#ffffff"} );
	//let e		= GltfUtil.get_debug_view( "target_a", json, bin, mat );

	let e		= GltfUtil.get_bone_view( "src", json, bin );
	let anim	= new Animation( Gltf.get_animation( json, bin ), true );
	let pm		= new PoseAnimator();
	let rig 	= e.add_com( "IKRig" ).init( null, true, IKRig.ARM_MIXAMO );

	gEntitySrc  = e;

	return ( dt )=>{
		pm.tick( dt ).update( anim, rig.pose );
		rig.apply_pose();
		complete_ik_pose( gEntitySrc, gIKPose );
		compute_limb( gEntitySrc, gIKPose );
		
		if( gModelA ){
			gIKPose.apply_rig( gModelA.IKRig );
			gModelA.IKRig.apply_pose();
		}
	}
}

function load_mesh_a( json, bin ){	
	let mat		= App.new_mat( "LowPolySkin", {color:"#ffffff"} );
	let e		= GltfUtil.get_debug_view( "target_a", json, bin, mat );
	//let e		= GltfUtil.get_bone_view( "target_a", json, bin );
	let tpose	= GltfUtil.get_pose( e, json, "tpose", true );
	let rig 	= e.add_com( "IKRig" ).init( tpose, false );
	tpose.apply();

	//e.Node.set_pos( 1.5, 0, 0 );
	//e.Node.set_pos( 0, .2, 0 );
	gModelA = e;
}

function load_mesh_b( json, bin ){	
	let mat		= App.new_mat( "LowPolySkin", {color:"#ffffff"} );
	let e		= GltfUtil.get_debug_view( "target_b", json, bin, mat );
	//let e		= GltfUtil.get_bone_view( "target_b", json, bin );
	let tpose	= GltfUtil.get_pose( e, json, "tpose", true );
	//let rig 	= e.add_com( "IKRig" ).init( tpose, false );
	tpose.apply();

	e.Node.set_pos( -1.5, 0, 0 );

	gModelB = e;
}

//#####################################################

import { Vec3, Quat, Transform } from "../../fungi/maths/Maths.js";
import Axis from "../../fungi/maths/Axis.js";

class IKPose{
	constructor(){
		this.target = new IKTarget();

		this.hip = {
			bind_height	: 0, // Use to help Scale movement.
			pos_dif 	: new Vec3(),
			dir			: new Vec3(),
			twist		: 0,
		};

		this.leg_l = {
			len_scale	: 0,
			dir 		: new Vec3(),
			joint_dir 	: new Vec3(),
		};
	}

	set_hip( dir=null, twist=null, pos=null, bind_h=null ){
		if( dir )			this.hip.dir.copy( dir );
		if( pos ) 			this.hip.pos_dif.copy( pos );
		if( twist != null )	this.hip.twist			= twist;
		if( bind_h != null)	this.hip.bind_height	= bind_h;
		return this;
	}
	set_leg_l( dir, j_dir, len_scl ){
		this.leg_l.dir.copy( dir );
		this.leg_l.joint_dir.copy( j_dir );
		this.leg_l.len_scale = len_scl;
		return this;
	}

	apply_rig( rig ){
		let i_hip	= rig.points.hip,
			tb 		= rig.tpose.bones[ i_hip.idx ],
			pb		= rig.pose.bones[ i_hip.idx ];

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		let q 		= new Quat();
		q.from_unit_vecs( Vec3.FORWARD, this.hip.dir );		// Compute Sway, TODO, Need Bone's actual Forward Direction
		q.mul( tb.world.rot );								// Add to WS Bind Pose
		q.pmul_axis_angle( this.hip.dir, this.hip.twist );	// Add Twist
		if( tb.p_idx != null ){								// To Local Space
			q.pmul_invert( rig.tpose.bones[ tb.p_idx ].world.rot );
		}

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		let h_scl 	= tb.world.pos.y / this.hip.bind_height;
		let p = Vec3.scale( this.hip.pos_dif, h_scl ).add( tb.local.pos );
		//this.hip_dif_pos.from_sub( b.world.pos, this.hip_bind_pos );
		//let p = new Vec3( bind.world.pos );
		//p[1] += ik.hip_dif_pos[1] * this.hip_scale[1];
		//p[0] += ik.hip_dif_pos[0] * this.hip_scale[1];
		//p[2] += ik.hip_dif_pos[2] * this.hip_scale[1];

		rig.pose.set_bone( i_hip.idx, q, p );

		this.run_limb( rig );
	}

	run_limb( rig ){
		let chain = rig.chains.leg_l;
		let limb = this.leg_l;

		let pt = new Transform();
		let ct = new Transform();

		rig.pose.get_parent_world( chain.first(), pt, ct );

		//App.Debug.pnt( ct.pos, "green", 0.07 ); 

		// Length of Animated Armature is Bad, Its the none-scaled length
		// Need to update Chain Length using TPose WorldSpace Positions
		let len = chain.len * limb.len_scale; //(this.ik_leg_l_len || chain.len) * ik.len_scale


		console.log( limb );

		this.target.from_pos_dir( ct.pos, limb.dir, limb.joint_dir, len );
		this.target.debug( App.Debug );

		// Get Position of Chain
		// Compute End Effector
		// 

			/*
			Pose.parent_world( this.rig.pose_a, chain.bones[0], this.pt, this.ct );
			this.target_pos
				.from_scale( ik.fwd, (this.ik_leg_l_len || chain.len) * ik.len_scale )
				.add( this.ct.pos );

			this.target.from_pos( this.ct.pos, this.target_pos, ik.up );
			if( this.leg_solver == 0 )	this.target.limb( chain, this.rig.bind_pose, this.rig.pose_a, this.pt );
			else 						this.target.three_bone( chain, this.rig.bind_pose, this.rig.pose_a, this.pt );
			*/
	}
}


function complete_ik_pose( e, ik_pose ){
	let rig 	= e.IKRig,
		pose 	= rig.pose;

	pose.update_world();
	App.Debug.reset();

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// REFACTORED
	let i_hip	= rig.points.hip;			// Hip IK Info
	let hip 	= pose.bones[ i_hip.idx ];	// Hip Bone
	
	let tb		= rig.tpose.bones[ i_hip.idx ];	

	let a_axis 	= new Axis().from_quat( hip.world.rot ); // Animated Axis
	let t_axis 	= new Axis().from_quat( tb.world.rot ); // TPose Axis

	//App.Debug.axis( a_axis, hip.world.pos, 0.4, "orange" );
	//App.Debug.axis( t_axis, hip.world.pos, 0.3, "red" );

	let q = new Quat();
	q	.from_unit_vecs( t_axis.z, a_axis.z )
		.mul( tb.world.rot );

	let s_axis 	= new Axis().from_quat( q ); // Swing Axis
	//App.Debug.axis( s_axis, hip.world.pos, 0.3, "yellow" );

	let sign	= ( Vec3.dot( s_axis.x, a_axis.y ) >= 0 )? -1:1;
	let twist	= Vec3.angle( s_axis.y, a_axis.y );
	
	q.pmul_axis_angle( a_axis.z, twist*sign);

	//App.Debug.quat( q, hip.world.pos, 0.2, "cyan" );


	let pos_dif = Vec3.sub( hip.world.pos, tb.world.pos );
	ik_pose.set_hip( a_axis.z, twist, pos_dif, tb.world.pos.y );
}


function complete_ik_pose_cp( e, ik_pose ){
	let rig 	= e.IKRig,
		pose 	= rig.pose;

	pose.update_world();

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// REFACTORED
	let i_hip	= rig.points.hip;			// Hip IK Info
	let hip 	= pose.bones[ i_hip.idx ];	// Hip Bone
	
	let tb		= rig.tpose.bones[ i_hip.idx ];	

	let t_up 	= Vec3.transform_quat( Vec3.UP, tb.world.rot ); // TPose Up
	let a_fwd 	= Vec3.transform_quat( Vec3.FORWARD, hip.world.rot ); // Animated Fwd
	let a_up 	= Vec3.transform_quat( Vec3.UP, hip.world.rot );	// Animated Up

	let s_lft 	= Vec3.cross( t_up, a_fwd ).norm();	// Swing Left
	let s_up 	= Vec3.cross( a_fwd, s_lft ).norm(); // Swing Up

	let sign	= ( Vec3.dot( s_lft, a_up ) < 0 )? 1:-1;
	let twist 	= Vec3.angle( s_up, a_up ) * sign;

	// Test
	let q		= Quat.axis_angle( a_fwd, twist );
	let up		= Vec3.transform_quat( s_up, q );

	App.Debug.ln( hip.world.pos, up.add( hip.world.pos ), "yellow" );


	//ik_pose.set_hip( a_fwd, twist );

	/*
	let a_axis 	= new Axis().from_quat( hip.world.rot ); // Animated Axis
	let t_axis 	= new Axis().from_quat( tb.world.rot ); // TPose Axis

	App.Debug.axis( a_axis, hip.world.pos, 0.4, "orange" );
	App.Debug.axis( t_axis, hip.world.pos, 0.3, "red" );

	let q = new Quat();
	q	.from_unit_vecs( t_axis.z, a_axis.z )
		.mul( tb.world.rot );

	let s_axis 	= new Axis().from_quat( q ); // Swing Axis
	App.Debug.axis( s_axis, hip.world.pos, 0.3, "yellow" );

	let sign	= ( Vec3.dot( s_axis.x, a_axis.y ) >= 0 )? -1:1;
	let twist	= Vec3.angle( s_axis.y, a_axis.y );
	
	q.pmul_axis_angle( a_axis.z, twist*sign);

	App.Debug.quat( q, hip.world.pos, 0.2, "cyan" );

	ik_pose.set_hip( a_axis.z, twist );
	*/
}


function complete_ik_pose_x( e, ik_pose ){
	let rig 	= e.IKRig,
		pose 	= rig.pose;

	pose.update_world();

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Original
	let i_hip	= rig.points.hip;			// Hip IK Info
	let hip 	= pose.bones[ i_hip.idx ];	// Hip Bone
	
	let tb		= rig.tpose.bones[ i_hip.idx ];	

	let a = new Vec3();
	let b = new Vec3();
	let c = new Vec3();
	let d = new Vec3();
	App.Debug.pnt( hip.world.pos, "orange", 0.03 );

	a.from_quat( hip.world.rot, Vec3.FORWARD );
	b.from_quat( hip.world.rot, Vec3.UP );

	let q = new Quat();
	let r = new Quat();
	q.from_unit_vecs( Vec3.FORWARD, a );
	q.mul( tb.world.rot );

	c.from_quat( q, Vec3.FORWARD );
	d.from_quat( q, Vec3.UP );

	r.from_axis_angle( a, -Vec3.angle( b, d ) );
	q.pmul( r );
	d.from_quat( q, Vec3.UP );

	App.Debug
		.ln( hip.world.pos, a.scale( 0.4 ).add( hip.world.pos ), "orange" )
		.ln( hip.world.pos, b.scale( 0.4 ).add( hip.world.pos ), "orange" );

	App.Debug
		.ln( hip.world.pos, c.scale( 0.3 ).add( hip.world.pos ), "yellow" )
		.ln( hip.world.pos, d.scale( 0.3 ).add( hip.world.pos ), "yellow" );

	a.from_quat( tb.world.rot, Vec3.FORWARD ).scale( 0.3 ).add( hip.world.pos ); // See T Pose Forward
	b.from_quat( tb.world.rot, Vec3.UP ).scale( 0.3 ).add( hip.world.pos );
	App.Debug
		.ln( hip.world.pos, a, "red" )
		.ln( hip.world.pos, b, "red" );
	/*
	a.from_scale( Vec3.FORWARD, 0.2 ).add( hip.world.pos );	// See Axis Forward
	b.from_scale( Vec3.UP, 0.2 ).add( hip.world.pos );
	App.Debug
		.ln( hip.world.pos, a, "cyan" )
		.ln( hip.world.pos, b, "cyan" );
	*/
}


function compute_limb( e, ik_pose ){
	let rig 	= e.IKRig,
		chain 	= rig.chains.leg_l,
		pose 	= rig.pose;

	let bf = pose.bones[ chain.first() ];
	let be = pose.bones[ chain.end_idx ];

	//App.Debug.pnt( bf.world.pos, "green", 0.07 );
	//App.Debug.pnt( be.world.pos, "red", 0.07 );

	let dir		= Vec3.sub( be.world.pos, bf.world.pos );
	let len		= dir.len();
	let j_dir	= Vec3.transform_quat( Vec3.BACK, bf.world.rot ); // THE Axis is Backwards, So farward is pointing back, Need to use Back to point forward

	ik_pose.set_leg_l( dir, j_dir, len / chain.len );
}

/*
	// Chain is the arm or leg bones, where end is the hand or foot.
	ik_compute_limb( chain, end, out, dt ){
		let a, b, c,
			p = new Vec3();

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// Get Reference to the 3 Points of the Limb. Forms a Triangle
		a = this.rig.get_bone( chain.bones[0] );
		b = this.rig.get_bone( chain.bones[1] );
		c = this.rig.get_bone( end );

		//App.debug.line( a.world.pos, Vec3.transform_quat( Vec3.FORWARD, a.world.rot ).add(a.world.pos), 0 );

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// Calculate the Forward IK Direction and the Distance to end effector.
		let dst = out.fwd
			.from_sub( c.world.pos, a.world.pos ) 	// Calc Forward Direction
			.len();									// Then Get the Length of the segment.

		out.fwd.norm();								// Normalizing the forward direction
		out.len_scale = dst / out.len;				// Scale he distance based on total limb length

		//p.from_sub( b.world.pos, a.world.pos );	// Calculate the Joint Dir (Knee, Elbow)  ITS JITTERY
		//p.from_cross( p, out.fwd );
		//out.up.from_cross( out.fwd, p ).norm();

		out.up.from_quat( a.world.rot, out.joint_dir ); // Calculate the Joint Dir (Knee, Elbow)  BETTER
		joint_dir is Vec3.BACK.clone() in original code, Maybe thigh bone for src is backwards??
		
		//if( dt < 0 ){
			//App.debug.point( a.world.pos, 0 );
			//App.debug.point( c.world.pos, 0 );

			//App.debug.line( a.world.pos, Vec3.scale( out.fwd, out.len_scale * out.len ).add(a.world.pos) );
			//App.debug.line( a.world.pos, Vec3.add( out.up, a.world.pos ) );
		//}

		//out.joint_dir								// Smooth movement of the Up direction since it can be jittery
		//	.set_target( out.up )				
		//	.update( dt );
		//console.log( "len_scale", dst, chain.len, out.len_scale );
	}
 */


// Find Foot's Up direction that will look forward when transformed by the bind rotation.
//if( find_up ){
//	v.from_quat( ct.rot, Vec3.UP );			// Get Current Direction
//	q.from_unit_vecs( Vec3.FORWARD, v );	// Difference between Forward and Dir
//	o.up.from_quat( q, Vec3.UP );			// UP offset to form Forward
//}
//
/*
	"black"		: "#000000",
	"white"		: "#ffffff",
	"red"		: "#ff0000",
	"green"		: "#00ff00",
	"blue"		: "#0000ff",
	"fuchsia"	: "#ff00ff",
	"cyan"		: "#00ffff",
	"yellow"	: "#ffff00",
	"orange"	: "#ff8000",
 */

</script><page-layout></page-layout>