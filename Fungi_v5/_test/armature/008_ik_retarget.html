<!DOCTYPE html><script type="module">
import App				from "../../fungi/App.js";
import IKTarget 		from "../../fungi.armature/IKTarget.js";

import Animation		from "../../fungi/lib/Animation.js";
import PoseAnimator		from "../../fungi.armature/PoseAnimator.js";

import XhrPromise		from "../../fungi/lib/XhrPromise.js";
import GltfUtil, {Gltf}	from "../../fungi/lib/GltfUtil.js";
import IKRig			from "../../fungi.armature/IKRig.js";

//#####################################################

App.builder( true )
	.use_armature()
	.load_shaders( "../fungi.armature/LowPolySkin.js" )
	.set_camera( 40, 20, 2.0, 0, 0.7, 0 )
	.add( init )
	//.render_loop( on_draw )
	.render_on_mouse()
	.build();

//#####################################################

let gAnimate, gEntitySrc;
function on_draw( dt, ss ){
	gAnimate( dt );
}

async function init(){
	let dl = await XhrPromise.get( 
		"../../_tmp/walking.gltf", "json", 
		"../../_tmp/walking.bin", "arraybuffer",
		//"../../files/models/vegeta.gltf", "json", 
		//"../../files/models/vegeta.bin", "arraybuffer",
		//"../../_tmp/robo_trex.gltf", "json", 
		//"../../_tmp/robo_trex.bin", "arraybuffer",
	);

	gAnimate = load_src( dl[0], dl[1] );
	
	//load_mesh_a( dl[2], dl[3] );
	//load_mesh_b( dl[4], dl[5] );

	gAnimate( 0.2 );

	complete_ik_pose( gEntitySrc, null );
	return true;
}

//#####################################################

function load_src( json, bin ){	
	//let mat		= App.new_mat( "LowPolySkin", {color:"#ffffff"} );
	//let e		= GltfUtil.get_debug_view( "target_a", json, bin, mat );

	let e		= GltfUtil.get_bone_view( "src", json, bin );
	let anim	= new Animation( Gltf.get_animation( json, bin ), true );
	let pm		= new PoseAnimator();
	let rig 	= e.add_com( "IKRig" ).init( null, true, IKRig.ARM_MIXAMO );

	gEntitySrc  = e;

	return ( dt )=>{
		pm.tick( dt ).update( anim, rig.pose );
		rig.apply_pose();
	}
}

function load_mesh_a( json, bin ){	
	let mat		= App.new_mat( "LowPolySkin", {color:"#ffffff"} );
	let e		= GltfUtil.get_debug_view( "target_a", json, bin, mat );
	//let e		= GltfUtil.get_bone_view( "target_a", json, bin );
	let tpose	= GltfUtil.get_pose( e, json, "tpose", true );
	//let rig 	= e.add_com( "IKRig" ).init( tpose, false );
	tpose.apply();

	e.Node.set_pos( 1.5, 0, 0 );
}

function load_mesh_b( json, bin ){	
	let mat		= App.new_mat( "LowPolySkin", {color:"#ffffff"} );
	let e		= GltfUtil.get_debug_view( "target_b", json, bin, mat );
	//let e		= GltfUtil.get_bone_view( "target_b", json, bin );
	let tpose	= GltfUtil.get_pose( e, json, "tpose", true );
	//let rig 	= e.add_com( "IKRig" ).init( tpose, false );
	tpose.apply();

	e.Node.set_pos( -1.5, 0, 0 );
}

//#####################################################

import { Vec3, Quat, Transform } from "../../fungi/maths/Maths.js";
import Axis from "../../fungi/maths/Axis.js";

class IKPose{
	constructor(){
		this.hip = {
			bind_height	: 0, // Use to help Scale movement.
			pos 		: new Vec3(),
			dir			: new Vec3(),
			twist		: 0,
		};
	}
}


function complete_ik_pose( e, ik_pose ){
	let rig 	= e.IKRig,
		pose 	= rig.pose;

	pose.update_world();

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// REFACTORED
	let i_hip	= rig.points.hip;			// Hip IK Info
	let hip 	= pose.bones[ i_hip.idx ];	// Hip Bone
	
	let tb		= rig.tpose.bones[ i_hip.idx ];	

	let a_axis 	= new Axis().from_quat( hip.world.rot ); // Animated Axis
	let t_axis 	= new Axis().from_quat( tb.world.rot ); // TPose Axis

	App.Debug.axis( a_axis, hip.world.pos, 0.4, "orange" );
	App.Debug.axis( t_axis, hip.world.pos, 0.3, "red" );

	let q = new Quat();
	q	.from_unit_vecs( t_axis.z, a_axis.z )
		.mul( tb.world.rot );

	let s_axis 	= new Axis().from_quat( q ); // Swing Axis
	App.Debug.axis( s_axis, hip.world.pos, 0.3, "yellow" );

	let sign	= ( Vec3.dot( s_axis.x, a_axis.y ) >= 0 )? -1:1;
	let twist	= Vec3.angle( s_axis.y, a_axis.y );
	
	q.pmul_axis_angle( a_axis.z, twist*sign);

	App.Debug.quat( q, hip.world.pos, 0.2, "cyan"  );
}


function complete_ik_pose_x( e, ik_pose ){
	let rig 	= e.IKRig,
		pose 	= rig.pose;

	pose.update_world();

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Original
	let i_hip	= rig.points.hip;			// Hip IK Info
	let hip 	= pose.bones[ i_hip.idx ];	// Hip Bone
	
	let tb		= rig.tpose.bones[ i_hip.idx ];	

	let a = new Vec3();
	let b = new Vec3();
	let c = new Vec3();
	let d = new Vec3();
	App.Debug.pnt( hip.world.pos, "orange", 0.03 );

	a.from_quat( hip.world.rot, Vec3.FORWARD );
	b.from_quat( hip.world.rot, Vec3.UP );

	let q = new Quat();
	let r = new Quat();
	q.from_unit_vecs( Vec3.FORWARD, a );
	q.mul( tb.world.rot );

	c.from_quat( q, Vec3.FORWARD );
	d.from_quat( q, Vec3.UP );

	r.from_axis_angle( a, -Vec3.angle( b, d ) );
	q.pmul( r );
	d.from_quat( q, Vec3.UP );

	App.Debug
		.ln( hip.world.pos, a.scale( 0.4 ).add( hip.world.pos ), "orange" )
		.ln( hip.world.pos, b.scale( 0.4 ).add( hip.world.pos ), "orange" );

	App.Debug
		.ln( hip.world.pos, c.scale( 0.3 ).add( hip.world.pos ), "yellow" )
		.ln( hip.world.pos, d.scale( 0.3 ).add( hip.world.pos ), "yellow" );

	a.from_quat( tb.world.rot, Vec3.FORWARD ).scale( 0.3 ).add( hip.world.pos ); // See T Pose Forward
	b.from_quat( tb.world.rot, Vec3.UP ).scale( 0.3 ).add( hip.world.pos );
	App.Debug
		.ln( hip.world.pos, a, "red" )
		.ln( hip.world.pos, b, "red" );
	/*
	a.from_scale( Vec3.FORWARD, 0.2 ).add( hip.world.pos );	// See Axis Forward
	b.from_scale( Vec3.UP, 0.2 ).add( hip.world.pos );
	App.Debug
		.ln( hip.world.pos, a, "cyan" )
		.ln( hip.world.pos, b, "cyan" );
	*/
}

// Find Foot's Up direction that will look forward when transformed by the bind rotation.
//if( find_up ){
//	v.from_quat( ct.rot, Vec3.UP );			// Get Current Direction
//	q.from_unit_vecs( Vec3.FORWARD, v );	// Difference between Forward and Dir
//	o.up.from_quat( q, Vec3.UP );			// UP offset to form Forward
//}
//
/*
	"black"		: "#000000",
	"white"		: "#ffffff",
	"red"		: "#ff0000",
	"green"		: "#00ff00",
	"blue"		: "#0000ff",
	"fuchsia"	: "#ff00ff",
	"cyan"		: "#00ffff",
	"yellow"	: "#ffff00",
	"orange"	: "#ff8000",
 */

</script><page-layout></page-layout>