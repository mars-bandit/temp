<!DOCTYPE html><script type="module">
import App				from "../../fungi/App.js";
import XhrPromise		from "../../fungi/lib/XhrPromise.js";
import GltfUtil,{Gltf}	from "../../fungi/lib/GltfUtil.js";

import Vec3 			from "../../fungi/maths/Vec3.js";
import Quat 			from "../../fungi/maths/Quat.js";
import Transform 		from "../../fungi/maths/Transform.js";

//#####################################################
App.builder( true )
	.use_armature()
	.load_shaders( "../fungi.armature/LowPolySkin.js" )
	.set_camera( 0, 0, 2.2, 0, 0.75, 0 )
	.add( init )
	.render_on_mouse()
	.build();

//#####################################################
async function init(){
	let dl = await XhrPromise.get( 
		"../../files/models/vegeta.gltf", "json", 
		"../../files/models/vegeta.bin", "arraybuffer",
	);

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Abstract Loading
	let mat	= App.new_mat( "LowPolySkin", { color:"white" } );
	//let e 	= GltfUtil.get_bone_view( "test", dl[0], dl[1] );
	let e 	= GltfUtil.get_debug_view( "test", dl[0], dl[1], mat );
	
	let tpose = TPose.new( e )
		.align_leg( ["LeftUpLeg", "LeftLeg"] )
		.align_leg( ["RightUpLeg", "RightLeg"] )
		.align_arm_left( ["LeftArm", "LeftForeArm"] )
		.align_arm_right( ["RightArm", "RightForeArm"] )
		.align_foot( "LeftFoot" )
		.align_foot( "RightFoot" )
		.build();

	tpose.apply();
	
	console.log( serialize_pose( "tpose", 0, tpose ) );

	//set_pose( e );
	return true;
}


function set_pose( e ){
	let arm = e.Armature;
	arm.get_e( "LeftUpLeg" ).Node.rot_by( 75, "x" );
	arm.get_e( "LeftLeg" ).Node.rot_by( -110, "x" );
	arm.get_e( "Neck" ).Node.rot_by( -40, "x" );
	arm.get_e( "LeftArm" ).Node.rot_by( 60, "x" );
	arm.get_e( "RightArm" ).Node.rot_by( 60, "x" );

	/**/
	arm.get_e( "Hips" ).Node.rot_by( 30, "x" );
	arm.get_e( "Neck" ).Node.set_scl( 2.0 );
	arm.get_e( "LeftHand" ).Node.set_scl( 2.5 );
	arm.get_e( "RightHand" ).Node.set_scl( 2.5 );

	arm.get_e( "LeftUpLeg" ).Node.set_scl( 0.5 );
	arm.get_e( "RightUpLeg" ).Node.set_scl( 0.5 );
}


/*
poses:[
	{ name:"tpose", skin:0, joints:[
		{ rot:[], scl:[] },
	]}
]
*/
function serialize_pose( name, skin, pose ){
	let json	= pose.bare_serialize(),
		buf		= "";

	for( let i=0; i < json.length; i++ ){
		if( i != 0 ) buf += ",\n";
		buf += "\t" + JSON.stringify( json[ i ] );
	}

	return `{ "name":"${name}", "skin":${skin}, "joints":[\n${buf}\n]}`;
}



class TPose{
	static new( e ){
		let p = new TPose();
		p.pose = e.Armature.new_pose();
		return p;
	}

	constructor(){ this.pose = null; }

	align_leg( b_names ){  align_chain( this.pose, Vec3.DOWN, b_names ); return this; }
	align_arm_left( b_names ){ align_chain( this.pose, Vec3.LEFT, b_names ); return this; }
	align_arm_right( b_names ){ align_chain( this.pose, Vec3.RIGHT, b_names ); return this; }
	align_foot( b_name ){ align_foot_forward( this.pose, b_name ); return this; }

	build(){ let p = this.pose; this.pose = null; return p; }
}

function align_chain( pose, dir, b_names ){
	let pt		= new Transform(),				// Parent Transform ( Current Bone's Parent );
		ct		= new Transform(),				// Child Transform ( Current Bone )
		aEnd	= b_names.length - 1,				// End Index
		f		= new Vec3(),					// Forward
		u		= new Vec3( dir ),				// Up
		l		= new Vec3(),					// Left
		r		= new Quat(),					// Final Rotation
		q		= new Quat(),					// Temp Rotation
		b 		= pose.get_bone( b_names[0] );	// Bone Reference
		
	// Parent Bone's Transform
	pose.get_parent_world( b.idx, pt );

	for( let i=0; i <= aEnd; i++ ){
		ct.from_add( pt, b.local );			// Calc current bones world transform

		/*

		console.log( b );
		App.Debug.pnt( pt.pos );
		App.Debug.pnt( ct.pos, "green" );
		App.Debug.quat( ct.rot, ct.pos );

		return;
		*/

		//App.debug
		//	.point( ct.pos, 2 )
		//	.line( ct.pos, Vec3.add( ct.pos, dir), 0 );
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// Up direction is where we need the bone to point to.
		// We then get the bone's current forward direction, use it
		// to get its left, then finish it off by recalculating
		// fwd to make it orthogonal. Want to try to keep the orientation
		// while ( fwd, lft ) realigning the up direction.
		f.from_quat( ct.rot, Vec3.FORWARD ); 		// Find Bone's Forward World Direction
		l.from_cross( u, f ).norm();				// Get World Left
		f.from_cross( l, u ).norm();				// Realign Forward
		r.from_axis( l, u, f );						// Create Rotation from 3x3 rot Matrix
		
		if( Quat.dot( r, ct.rot ) < 0 ) r.negate();	// Do a Inverted rotation check, negate it if under zero.
		
		//r.pmul( q.from_invert( pt.rot ) );		// Move rotation to local space
		r.pmul_invert( pt.rot );					// Move rotation to local space
		pose.set_bone( b.idx, r );					// Update Pose with new ls rotation
		
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// If not the last bone, take then the new rotation to calc the next parents
		// world space transform for the next bone on the list.
		if( i != aEnd){
			pt.add( r, b.local.pos, b.local.scl );
			b = pose.get_bone( b_names[i+1] );
		}
	}
}

function align_foot_forward( pose, foot ){
	let pt	= new Transform(),
		ct	= new Transform(),
		v	= new Vec3(),
		q	= new Quat(),
		b	= pose.get_bone( foot );

	pose.get_parent_world( b.idx, pt, ct );	// Get the Parent and Child Transforms. e.Armature,
	
	ct.transform_vec( [0,b.len,0], v );			// Get the Tails of the Bone
	v.sub( ct.pos );							// Get The direction to the tail
	v[1] = 0;									// Flatten vector to 2D by removing Y Position
	v.norm();									// Make it a unit vector
	q	.from_unit_vecs( v, Vec3.FORWARD )		// Rotation needed to point the foot forward.
		.mul( ct.rot )							// Move WS Foot to point forward
		.pmul_invert( pt.rot );					// To Local Space
	pose.set_bone( b.idx, q );					// Save to Pose
}

// ####################################################################################

</script><page-layout></page-layout>