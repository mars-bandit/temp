<!DOCTYPE html>
<html><head><style>
	html,body{ margin:0px; padding:0px; width:100%; height:100%; }
	body{background-color:#404040;}
	canvas{ border:0px solid red; }
	div{ display:flex; width:100%; height:100%; align-items:center; justify-content:center; }
	button{ position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); }
</style></head><body>
	<button>START AR SESSION</button>
	<div><canvas id="pg_canvas"></canvas></div>
	
<script type="module">

let gl, canvas, shader, pg_width, pg_height, mesh;

let camera = { 
	pos		: [1,0,2], 			// Vector Position
	view	: m4_identity(),	// View Matrix
	proj	: m4_identity(),	// Projection Matrix
	updated : true,
	set( x,y,z ){ this.pos[0]=x; this.pos[1]=y; this.pos[2]=z; this.updated=true; },
};

window.addEventListener("load", ()=>{
	console.log( document.getElementsByTagName("button") );

	init_gl();
	init_shader();
	init_camera();

	let idx		= new Uint16Array( [ 0,1,2, 2,3,0 ] );
	let vert	= new Float32Array( [ -0.5, 0.5, 0.0, -0.5, -0.5, 0.0, 0.5, -0.5, 0.0, 0.5, 0.5, 0.0, ] );
	mesh		= new_vao( vert, idx );

	draw();
});


// #region RENDERING
let time = 0;
function draw(){
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	time += 0.008;
	camera.set( 5 * Math.cos( time ), 0, 5 * Math.sin( time ) );

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	update_camera();
	shader.use();
	mesh.draw();

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	requestAnimationFrame( draw );
}
// #endregion


// #region INITIAL
function init_gl(){
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	pg_width		= window.innerWidth;
	pg_height		= window.innerHeight;
	
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	canvas			= document.getElementById( "pg_canvas" );
	canvas.width	= pg_width;
	canvas.height	= pg_height;

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	gl				= canvas.getContext( "webgl2" );
	gl.viewport( 0, 0, pg_width, pg_height );
}

function init_shader(){ 
	shader = new_shader( VERT_SRC, FRAG_SRC );
	shader.proj_loc = gl.getUniformLocation( shader.prog, "proj_mtx" );
	shader.view_loc = gl.getUniformLocation( shader.prog, "view_mtx" );

	shader.use = function(){
		gl.useProgram( this.prog );
		gl.uniformMatrix4fv( this.proj_loc, false, camera.proj );
		gl.uniformMatrix4fv( this.view_loc, false, camera.view );
	}
}

function init_camera(){
	m4_perspective( camera.proj, 45 * Math.PI / 180, pg_width / pg_height, 0.01, 1000 );
}

function update_camera(){
	if( !camera.updated ) return;
	m4_look_at( camera.pos, [0,0,0], [0,1,0], camera.view );
	camera.updated = false;
}
// #endregion


// #region SHADERS
function new_shader( v_src, f_src ){
	let vert_sh		= compile_shader( v_src, gl.VERTEX_SHADER );
	if( !vert_sh )	return null;

	let frag_sh		= compile_shader( f_src, gl.FRAGMENT_SHADER);
	if( !frag_sh ){	gl.deleteShader( vert_sh ); return null; }

	//Link shaders together
	let prog = gl.createProgram();
	gl.attachShader( prog, vert_sh );
	gl.attachShader( prog, frag_sh );
	gl.linkProgram( prog );

	// Check if successful
	if( !gl.getProgramParameter( prog, gl.LINK_STATUS ) ){
		console.error("Error creating shader program.", gl.getProgramInfoLog(prog));
		gl.deleteProgram( prog ); return null;
	}
			
	// Can delete the shaders since the program has been made.
	gl.detachShader( prog, vert_sh ); // TODO, detaching might cause issues on some browsers, Might only need to delete.
	gl.detachShader( prog, frag_sh );
	gl.deleteShader( frag_sh );
	gl.deleteShader( vert_sh );

	return { prog };
}

function compile_shader( src, type ){
	let shader = gl.createShader( type );
	gl.shaderSource(shader,src);
	gl.compileShader(shader);

	//Get Error data if shader failed compiling
	if( !gl.getShaderParameter( shader, gl.COMPILE_STATUS )){
		console.error("Error compiling shader : " + src, gl.getShaderInfoLog(shader));
		gl.deleteShader(shader);
		return null;
	}
	return shader;
}
// #endregion


// #region MESH
function new_vao( v_ary, i_ary=null ){
	let elm_cnt, buf, vao = gl.createVertexArray();
	gl.bindVertexArray( vao );

	///ELEMENT_ARRAY_BUFFER
	buf = gl.createBuffer();
	gl.bindBuffer( gl.ARRAY_BUFFER, buf );
	gl.bufferData( gl.ARRAY_BUFFER, v_ary, gl.STATIC_DRAW );
	gl.enableVertexAttribArray( 0 );
	gl.vertexAttribPointer( 0, 3, gl.FLOAT, false, 0, 0 );

	if( i_ary ){
		buf = gl.createBuffer();
		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, buf );
		gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, i_ary, gl.STATIC_DRAW );
		elm_cnt = i_ary.length;
	}else elm_cnt = v_ary.length / 3;

	gl.bindVertexArray( null );
	gl.bindBuffer( gl.ARRAY_BUFFER, null );

	return { 
		vao, draw_mode:4, elm_cnt, is_index: (i_ary),
		draw: function(){
			gl.bindVertexArray( this.vao );
			if( this.is_index )	gl.drawElements( this.draw_mode, this.elm_cnt, gl.UNSIGNED_SHORT, 0 );
			else 				gl.drawArrays( this.draw_mode, 0, this.elm_cnt );
		}
	};
}
// #endregion


// #region MATRIX 4x4
function m4_identity(){
	let out = new Float32Array( 16 );
	out[0] = out[5] = out[10] = out[15] = 1;
	return out;
}

function m4_perspective( out, fovy, aspect, near, far ){
	let f = 1.0 / Math.tan(fovy / 2),
		nf = 1 / (near - far);
	out[0] = f / aspect;
	out[1] = 0;
	out[2] = 0;
	out[3] = 0;
	out[4] = 0;
	out[5] = f;
	out[6] = 0;
	out[7] = 0;
	out[8] = 0;
	out[9] = 0;
	out[10] = (far + near) * nf;
	out[11] = -1;
	out[12] = 0;
	out[13] = 0;
	out[14] = (2 * far * near) * nf;
	out[15] = 0;
}

//This creates a View Matrix, not a World Matrix. That means Inverted World Matrix
function m4_look_at( eye, center, up, out ){
	let x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
	let eyex = eye[0];
	let eyey = eye[1];
	let eyez = eye[2];
	let upx = up[0];
	let upy = up[1];
	let upz = up[2];
	let centerx = center[0];
	let centery = center[1];
	let centerz = center[2];

	if (Math.abs(eyex - centerx) < 0.000001 &&
		Math.abs(eyey - centery) < 0.000001 &&
		Math.abs(eyez - centerz) < 0.000001) {
		return Mat4.identity( out );
	}

	z0 = eyex - centerx;
	z1 = eyey - centery;
	z2 = eyez - centerz;

	len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
	z0 *= len;
	z1 *= len;
	z2 *= len;

	x0 = upy * z2 - upz * z1;
	x1 = upz * z0 - upx * z2;
	x2 = upx * z1 - upy * z0;
	len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);

	if (!len) {
		x0 = 0;
		x1 = 0;
		x2 = 0;
	} else {
		len = 1 / len;
		x0 *= len;
		x1 *= len;
		x2 *= len;
	}

	y0 = z1 * x2 - z2 * x1;
	y1 = z2 * x0 - z0 * x2;
	y2 = z0 * x1 - z1 * x0;

	len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
	if (!len) {
		y0 = 0;
		y1 = 0;
		y2 = 0;
	} else {
		len = 1 / len;
		y0 *= len;
		y1 *= len;
		y2 *= len;
	}

	out[0] = x0;
	out[1] = y0;
	out[2] = z0;
	out[3] = 0;
	out[4] = x1;
	out[5] = y1;
	out[6] = z1;
	out[7] = 0;
	out[8] = x2;
	out[9] = y2;
	out[10] = z2;
	out[11] = 0;
	out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
	out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
	out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
	out[15] = 1;

	return out;
}
// #endregion


// #region CONSTANTS
const VERT_SRC = `#version 300 es
	layout(location=0) in vec3 a_pos;

	uniform mat4 proj_mtx;
	uniform mat4 view_mtx;

	void main(void){
		gl_Position = proj_mtx * view_mtx * vec4( a_pos, 1.0 );
	}`;

const FRAG_SRC = `#version 300 es
	precision mediump float;

	//uniform vec3 u_color;
	const vec3 u_color = vec3(0.0);
	out vec4 out_color;

	void main(void){ out_color = vec4( u_color, 1.0 ); }`;
// #endregion

</script></body></html>